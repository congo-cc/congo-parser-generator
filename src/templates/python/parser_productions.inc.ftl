[#-- This template contains the core logic for generating the various parser routines. --]

[#import "common_utils.inc.ftl" as CU]

[#var nodeNumbering = 0]
[#--
[#var NODE_USES_PARSER = settings.nodeUsesParser]
[#var NODE_PREFIX = grammar.nodePrefix]
--]
[#var currentProduction]
[#var topLevelExpansion] [#-- A "one-shot" indication that we are processing 
                              an expansion immediately below the BNF production expansion, 
                              ignoring an ExpansionSequence that might be there. This is
                              primarily, if not exclusively, for allowing JTB-compatible
                              syntactic trees to be built. While seemingly silly (and perhaps could be done differently), 
                              it is also a bit tricky, so treat it like the Holy Hand-grenade in that respect. 
                          --]

[#macro Productions]
# ===================================================================
# Start of methods for BNF Productions
# This code is generated by the parser_productions.inc.ftl template.
# ===================================================================
[#list grammar.parserProductions as production]
  [@CU.firstSetVar production.expansion/]
  [#if !production.onlyForLookahead]
    [#set currentProduction = production]
    [@ParserProduction production/]
  [/#if]
[/#list]
[#if settings.faultTolerant]
    [@BuildRecoverRoutines /]
[/#if]
[/#macro]

[#macro ParserProduction production]
   [#set nodeNumbering = 0]
   [#set newVarIndex = 0 in CU] 
   [#-- Generate the method modifiers and header --]
   [#if production.leadingComments?has_content]
   # ${production.leadingComments}
   [/#if]
   # ${production.location}
   ${globals.startProduction()}def parse_${production.name}(self[#if production.parameterList?has_content], ${globals.translateParameters(production.parameterList)}[/#if]):
   [#-- Now generate the body --]
      # import pdb; pdb.set_trace()
   [#-- OMITTED: "if (cancelled) throw new CancellationException();" --]
      prev_production = self.currently_parsed_production
      self.currently_parsed_production = '${production.name}'
   [#--${production.javaCode!}
      This is actually inserted further down because
      we want the prologue java code block to be able to refer to
      CURRENT_NODE.
   --]
   [#set topLevelExpansion = false]
      ${BuildCode(production, 8)}
      self.currently_parsed_production = prev_production
    # end of parse_${production.name}${globals.endProduction()}
[/#macro]

[#--
   Macro to build routines that scan up to the start of an expansion
   as part of a recovery routine
--]
[#macro BuildRecoverRoutines]
   [#list grammar.expansionsNeedingRecoverMethod as expansion]
    def ${expansion.recoverMethodName}(self):
        initial_token = self.last_consumed_token
        skipped_tokens = []
        success = False
        while self.last_consumed_token.type != EOF:
         [#if expansion.simpleName = "OneOrMore" || expansion.simpleName = "ZeroOrMore"]
            if (${ExpansionCondition(expansion.nestedExpansion)}):
         [#else]
            if (${ExpansionCondition(expansion)}):
         [/#if]
                success = True
                break
         [#if expansion.simpleName = "ZeroOrMore" || expansion.simpleName = "OneOrMore"]
            [#var followingExpansion = expansion.followingExpansion]
            [#list 1..1000000 as unused]
               [#if followingExpansion?is_null][#break][/#if]
                  [#if followingExpansion.maximumSize >0]
                     [#if followingExpansion.simpleName = "OneOrMore" || followingExpansion.simpleName = "ZeroOrOne" || followingExpansion.simpleName = "ZeroOrMore"]
            if (${ExpansionCondition(followingExpansion.nestedExpansion)}):
                     [#else]
               if (${ExpansionCondition(followingExpansion)}):
                     [/#if]
                  success = True
                  break
                  [/#if]
                  [#if !followingExpansion.possiblyEmpty][#break][/#if]
                     [#if followingExpansion.followingExpansion?is_null]
               if self.outer_follow_set is not None:
                  if self.next_token_type() in self.outer_follow_set:
                     success = True
                     break
                     [#break/]
                  [/#if]
               [#set followingExpansion = followingExpansion.followingExpansion]
            [/#list]
         [/#if]
            self.last_consumed_token = self.next_token(self.last_consumed_token)
            skipped_tokens.append(self.last_consumed_token)
        if not success and skipped_tokens:
             self.last_consumed_token = initial_token
        if success and skipped_tokens:
            iv = InvalidNode(self)
            [#-- OMITTED: "iv.copyLocationInfo(skippedTokens.get(0));" --]
            for tok in skipped_tokens:
                iv.add_child(tok)
            [#-- OMITTED: "iv.setEndOffset(tok.getEndOffset());" --]
        #   if self.debug_fault_tolerant:
        #       logger.info('Skipping %s tokens starting at: %s', len(skipped_tokens), skipped_tokens[0].location)
            self.push_node(iv)
        self.pending_recovery = not success

   [/#list]
[/#macro]

[#macro BuildCode expansion indent]
   [#var is=""?right_pad(indent)]
   [#-- ${is}# DBG > BuildCode ${indent} ${expansion.simpleName} --]
   [#if expansion.simpleName != "ExpansionSequence" && expansion.simpleName != "ExpansionWithParentheses"]
${is}# Code for ${expansion.simpleName} specified at ${expansion.location}
   [/#if]
      [@CU.HandleLexicalStateChange expansion false indent]
         [#if settings.faultTolerant && expansion.requiresRecoverMethod && !expansion.possiblyEmpty]
${is}if self.pending_recovery:
${is}#   if self.debug_fault_tolerant:
${is}#       logger.info('Re-synching to expansion at: ${expansion.location?j_string}')
${is}   self.${expansion.recoverMethodName}()
      [/#if]
         [@TreeBuildingAndRecovery expansion indent/]
      [/@CU.HandleLexicalStateChange]
   [#-- ${is}# DBG < BuildCode ${indent} ${expansion.simpleName} --]
[/#macro]

[#macro TreeBuildingAndRecovery expansion indent]
[#var is=""?right_pad(indent)]
[#-- ${is}# DBG > TreeBuildingAndRecovery ${indent} --]
   [#var production = null,
         treeNodeBehavior,
         buildingTreeNode=false, 
         nodeVarName,
         javaCodePrologue = null,
         parseExceptionVar = CU.newVarName("parseException"),
         callStackSizeVar = CU.newVarName("callStackSize"),
         canRecover = settings.faultTolerant && expansion.tolerantParsing && expansion.simpleName != "Terminal"
   ]
   [#set treeNodeBehavior = resolveTreeNodeBehavior(expansion)]
   [#if expansion == currentProduction]
      [#set production = currentProduction]
      [#set javaCodePrologue = production.javaCode]
   [/#if]
   [#if treeNodeBehavior??]
      [#if settings.treeBuildingEnabled]
         [#set buildingTreeNode = true]
         [#set nodeVarName = nodeVar(production??)]
      [/#if]
   [/#if]
   [#if !buildingTreeNode && !canRecover]
       [#-- We need neither tree nodes nor recovery code; do the simple one. --]
${globals.translateCodeBlock(javaCodePrologue, indent)}[#rt]
${BuildExpansionCode(expansion, indent)}
   [#else]
      [#-- We need tree nodes and/or recovery code. --] 
      [#if buildingTreeNode]
         [#-- Build the tree node (part 1). --]
         [@buildTreeNode production treeNodeBehavior nodeVarName /]
      [/#if]
   [/#if]
   [#-- The prologue code can refer to CURRENT_NODE at this point. --]
${globals.translateCodeBlock(javaCodePrologue, indent)}
${is}${parseExceptionVar} = None
${is}${callStackSizeVar} = len(self.parsing_stack)
${is}try:
${is}    pass  # in case there's nothing else in the try clause!
[#-- ${is}    # nested code starts, passing indent of ${indent + 4} --]
${BuildExpansionCode(expansion, indent + 4)}
[#-- ${is}    # nested code ends --]
${is}except ParseException as e:
${is}    ${parseExceptionVar} = e
            [#if !canRecover]
              [#if settings.faultTolerant]
${is}    if self.is_tolerant: self.pending_recovery = True
              [/#if]
${is}    raise
            [#else]
${is}    if not self.is_tolerant: raise
${is}    self.pending_recovery = True
         ${expansion.customErrorRecoveryBlock!}
             [#if !production?is_null && production.returnType != "void"]
                [#var rt = production.returnType]
                [#-- We need a return statement here or the code won't compile! --]
                [#if rt = "int" || rt="char" || rt=="byte" || rt="short" || rt="long" || rt="float"|| rt="double"]
${is}       return 0
                [#else]
${is}       return None
                [/#if]
             [/#if]
          [/#if]
${is}finally:         
      [#if buildingTreeNode]
      [#-- Build the tree node (part 2). --]
${is}    [@buildTreeNodeEpilogue treeNodeBehavior nodeVarName parseExceptionVar indent /]
      [/#if]
   [#-- ${is}# DBG < TreeBuildingAndRecovery ${indent} --]
[/#macro]

[#macro buildTreeNodeEpilogue treeNodeBehavior nodeVarName parseExceptionVar indent]
   [#var is=""?right_pad(indent)]
${is}    if ${nodeVarName}:
${is}       if ${parseExceptionVar} is None:
${is}          self.close_node_scope(${nodeVarName}, ${closeCondition(treeNodeBehavior)})
      [#if treeNodeBehavior?? && treeNodeBehavior.LHS??]
         [#-- LHS should be built --]
${is}          try:
${is}             ${treeNodeBehavior.LHS} = self.peek_node()
${is}          except Exception:
${is}             ${treeNodeBehavior.LHS} = None
      [/#if]
      [#list grammar.closeNodeHooksByClass[nodeClassName(treeNodeBehavior)]! as hook]
${is}          ${hook}(${nodeVarName})
      [/#list]
${is}    else:
   [#if settings.faultTolerant]
${is}            self.close_node_scope(${nodeVarName}, True)
${is}            ${nodeVarName}.dirty = True
   [#else]
${is}            self.clear_node_scope()
   [/#if]
${globals.popNodeVariableName()!}
   [#-- ${is}# DBG < TreeBuildingAndRecovery ${indent} --]
[/#macro]

[#function closeCondition treeNodeBehavior]
   [#var cc = "true"]
   [#if treeNodeBehavior??]
      [#if treeNodeBehavior.condition?has_content]
         [#set cc = treeNodeBehavior.condition]
         [#if treeNodeBehavior.gtNode]
            [#set cc = "nodeArity() " + treeNodeBehavior.initialShorthand  + cc]
         [/#if]
      [/#if]
   [/#if]
   [#return cc/]
[/#function]

[#function nodeClassName treeNodeBehavior]
   [#if treeNodeBehavior?? && treeNodeBehavior.nodeName??] 
      [#return NODE_PREFIX + treeNodeBehavior.nodeName]
   [/#if]
   [#return NODE_PREFIX + currentProduction.name/]
[/#function]

[#function resolveTreeNodeBehavior expansion]
   [#var treeNodeBehavior = expansion.treeNodeBehavior]
   [#var isProduction = false]
   [#if expansion.simpleName = "BNFProduction"]
      [#set isProduction = true]
   [/#if]
   [#if !treeNodeBehavior??] 
      [#if isProduction && !settings.nodeDefaultVoid 
                        && !grammar.nodeIsInterface(expansion.name)
                        && !grammar.nodeIsAbstract(expansion.name)]
         [#if settings.smartNodeCreation]
            [#set treeNodeBehavior = {"nodeName" : expansion.name!"nemo", "condition" : "1", "gtNode" : true, "void" :false, "initialShorthand" : ">"}]
         [#else]
            [#set treeNodeBehavior = {"nodeName" : expansion.name!"nemo", "condition" : null, "gtNode" : false, "void" : false}]
         [/#if]
      [/#if]
   [/#if]
   [#if treeNodeBehavior?? && treeNodeBehavior.neverInstantiated?? && treeNodeBehavior.neverInstantiated]
      [#return null/]
   [/#if]
   [#return treeNodeBehavior]
[/#function]

[#function nodeVar isProduction]
   [#var nodeVarName]
   [#if isProduction]
      [#set nodeVarName = "thisProduction"] [#-- [JB] maybe should be "CURRENT_PRODUCTION" or "THIS_PRODUCTION" to match "CURRENT_NODE"? --]
   [#else]
      [#set nodeNumbering = nodeNumbering +1]
      [#set nodeVarName = currentProduction.name + nodeNumbering] 
   [/#if]
   [#return nodeVarName/]
[/#function]

[#macro buildTreeNode production treeNodeBehavior nodeVarName indent]
   ${globals.pushNodeVariableName(nodeVarName)!}
   [@createNode nodeClassName(treeNodeBehavior) nodeVarName indent /]
[/#macro]

[#--  Boilerplate code to create the node variable --]
[#macro createNode nodeName nodeVarName indent]
[#var is=""?right_pad(indent)]
${is}${nodeVarName} = None
${is}if self.build_tree:
${is}    ${nodeVarName} = ${nodeName}([#if settings.nodeUsesParser]self[#else]self.input_source[/#if])
${is}    self.open_node_scope(${nodeVarName})
[/#macro]

[#function nodeClassName treeNodeBehavior]
   [#if treeNodeBehavior?? && treeNodeBehavior.nodeName??]
      [#return NODE_PREFIX + treeNodeBehavior.nodeName]
   [/#if]
   [#return NODE_PREFIX + currentProduction.name]
[/#function]

[#macro BuildExpansionCode expansion indent]
[#var is=""?right_pad(indent)]
[#var classname=expansion.simpleName]
[#-- ${is}# DBG > BuildExpansionCode ${indent} ${classname} --]
    [#var prevLexicalStateVar = CU.newVarName("previousLexicalState")]
   [#-- take care of the non-tree-building classes --]
   [#if classname = "CodeBlock"]
${BuildExpansionCode(expansion.nestedExpansion, indent)}
   [#elseif classname = "UncacheTokens"]
${is}self.uncache_tokens()
   [#elseif classname = "Failure"]
      [@BuildCodeFailure expansion indent /]
   [#elseif classname = "Assertion"]
      [@BuildAssertionCode expansion indent /]
   [#elseif classname = "TokenTypeActivation"]
      [@BuildCodeTokenTypeActivation expansion indent /]
   [#elseif classname = "TryBlock"]
      [@BuildCodeTryBlock expansion indent /]
   [#elseif classname = "AttemptBlock"]
      [@BuildCodeAttemptBlock expansion indent /]
   [#else]
      [#-- take care of the tree node (if any) --]
      [@TreeBuildingAndRecovery expansion]
         [#if classname = "BNFProduction"]
            [#-- The tree node having been built, now build the actual top-level expansion --]
            [#set topLevelExpansion = true]
            // top-level expansion ${expansion.nestedExpansion.simpleName}
            [@BuildCode expansion.nestedExpansion indent /]
         [#else]
            [#-- take care of terminal and non-terminal expansions; they cannot contain child expansions --]
            [#if classname = "NonTerminal"]
               [@BuildCodeNonTerminal expansion indent /]
            [#elseif classname = "Terminal"]
               [@BuildCodeTerminal expansion indent /]
            [#else]
               [#-- take care of the syntactical expansions (which can contain child expansions) --]
               [#-- capture the top-level indication in order to restore when bubbling up --]
               [#var stackedTopLevel = topLevelExpansion]
               [#if topLevelExpansion && classname != "ExpansionSequence"]
                  [#-- turn off top-level indication unless an expansion sequence (the tree node has already been determined when this nested template is expanded) --]
                  [#set topLevelExpansion = false]
               [/#if]
               [#if classname = "ZeroOrOne"]
                  [@BuildCodeZeroOrOne expansion indent /]
               [#elseif classname = "ZeroOrMore"]
                  [@BuildCodeZeroOrMore expansion indent /]
               [#elseif classname = "OneOrMore"]
                  [@BuildCodeOneOrMore expansion indent /]
               [#elseif classname = "ExpansionChoice"]
                  [@BuildCodeChoice expansion indent /]
               [#elseif classname = "ExpansionWithParentheses"]
                  [@BuildExpansionCode(expansion.nestedExpansion, indent) /]
               [#elseif classname = "ExpansionSequence"]
                  [@BuildCodeSequence expansion indent /] [#-- leave the topLevelExpansion one-shot alone (see above) --]
               [/#if]
               [#set topLevelExpansion = stackedTopLevel]
            [/#if]
         [/#if]
      [/@TreeBuildingAndRecovery]
   [/#if]
[#-- ${is}# DBG < BuildExpansionCode ${indent} ${classname} --]
[/#macro]

[#-- The following macros build expansions that never build tree nodes. --]

[#macro BuildCodeFailure fail indent]
[#var is = ""?right_pad(indent)]
[#-- ${is}# DBG > BuildCodeFailure ${indent} --]
    [#if fail.code?is_null]
      [#if fail.exp??]
${is}self.fail('Failure: %s' % "${fail.exp?j_string}")
      [#else]
${is}self.fail('Failure')
      [/#if]
    [#else]
${globals.translateCodeBlock(fail.code, indent)}
    [/#if]
[#-- ${is}# DBG < BuildCodeFailure ${indent} --]
[/#macro]

[#macro BuildAssertionCode assertion indent]
[#var is = ""?right_pad(indent)]
[#var optionalPart = ""]
[#if assertion.messageExpression??]
  [#set optionalPart = " + " + globals.translateExpression(assertion.messageExpression)]
[/#if]
[#var assertionMessage = "Assertion at: " + assertion.location?j_string + " failed."]
[#if assertion.assertionExpression??]
${is}if not (${globals.translateExpression(assertion.assertionExpression)}):
${is}    self.fail("${assertionMessage}"${optionalPart})
[/#if]
[#if assertion.expansion??]
${is}if [#if !assertion.expansionNegated]not [/#if]self.${assertion.expansion.scanRoutineName}():
${is}    self.fail("${assertionMessage}"${optionalPart})
[/#if]
[/#macro]

[#macro BuildCodeTokenTypeActivation activation indent]
[#var is = ""?right_pad(indent)]
[#-- ${is}# DBG > BuildCodeTokenTypeActivation ${indent} --]
[#if activation.deactivate]
${is}self.deactivate_token_types(
[#else]
${is}self.activate_token_types(
[/#if]
[#list activation.tokenNames as name]
${is}    ${name}[#if name_has_next],[/#if]
[/#list]
${is})
[#-- ${is}# DBG < BuildCodeTokenTypeActivation ${indent} --]
[/#macro]

[#macro BuildCodeTryBlock tryblock indent]
[#var is = ""?right_pad(indent)]
${is}# DBG > BuildCodeTryBlock ${indent}
${is}try:
${BuildCode(tryblock.nestedExpansion, indent + 4)}
   [#list tryblock.catchBlocks as catchBlock]
   # TODO verify indentation
${is}${catchBlock}
   [/#list]
   # TODO verify indentation
${is}${tryblock.finallyBlock!}
${is}# DBG < BuildCodeTryBlock ${indent}
[/#macro]

[#macro BuildCodeAttemptBlock attemptBlock indent]
[#var is = ""?right_pad(indent)]
${is}# DBG > BuildCodeAttemptBlock ${indent}
${is}try:
${is}    self.stash_parse_state()
${BuildCode(attemptBlock.nestedExpansion, indent + 4)}
${is}    self.pop_parse_state()
${is}except ParseException:
${is}    self.restore_stashed_parse_state()
${BuildCode(attemptBlock.recoveryExpansion, indent + 4)}
${is}# DBG < BuildCodeAttemptBlock ${indent}
[/#macro]

[#-- The following macros build expansions that might build tree nodes (could be called "syntactic" nodes). --]

[#macro BuildCodeNonTerminal nonterminal indent]
[#var is = ""?right_pad(indent)]
[#-- ${is}# DBG > BuildCodeNonTerminal ${indent} ${nonterminal.production.name} --]
   [#var production = nonterminal.production]
${is}self.push_onto_call_stack('${nonterminal.containingProduction.name}', '${nonterminal.inputSource?j_string}', ${nonterminal.beginLine}, ${nonterminal.beginColumn})
[#if settings.faultTolerant]
  [#var followSet = nonterminal.followSet]
  [#if !followSet.incomplete]
    [#if !nonterminal.beforeLexicalStateSwitch]
${is}self.outer_follow_set = self.${nonterminal.followSetVarName}
    [#else]
${is}self.outer_follow_set = None
    [/#if]
  [#elseif !followSet.isEmpty()]
${is}if self.outer_follow_set is not None:
${is}    new_follow_set = set(self.${nonterminal.followSetVarName}) | self.outer_follow_set
${is}    self.outer_follow_set = new_follow_set
  [/#if]
[/#if]
${is}try:
${is}    [#if !nonterminal.LHS?is_null && production.returnType != "void"]${nonterminal.LHS} = [/#if]self.parse_${nonterminal.name}(${globals.translateNonterminalArgs(nonterminal.args)})
   [#if !nonterminal.LHS?is_null && production.returnType = "void"]
${is}    try:
${is}        ${nonterminal.LHS} = self.peek_node()
${is}    except Exception:
${is}        ${nonterminal.LHS} = None
   [/#if]
   [#if !nonterminal.childName?is_null]
${is}    if self.build_tree:
${is}        child = self.peek_node()
${is}        name = '${nonterminal.childName}'
     [#if nonterminal.multipleChildren]
${is}        ${globals.currentNodeVariableName}.add_to_named_child_list(name, child)
     [#else]
${is}        ${globals.currentNodeVariableName}.set_named_child(name, child)
     [/#if]
   [/#if]
${is}finally:
${is}    self.pop_call_stack()
[#-- ${is}# DBG < BuildCodeNonTerminal ${indent} ${nonterminal.production.name} --]
[/#macro]

[#macro BuildCodeTerminal terminal indent]
[#var is = ""?right_pad(indent), regexp=terminal.regexp]
[#-- ${is}# DBG > BuildCodeRegexp ${indent} --]
  [#var LHS = ""]
  [#if terminal.lhs??][#set LHS = terminal.lhs + "="][/#if]
  [#if !settings.faultTolerant]
${is}${LHS}self.consume_token(${regexp.label})
  [#else]
    [#var tolerant = terminal.tolerantParsing?string("True", "False")]
    [#var followSetVarName = "self." + terminal.followSetVarName]
    [#if terminal.followSet.incomplete]
      [#set followSetVarName = "follow_set" + CU.newID()]
${is}${followSetVarName} = None
${is}if self.outer_follow_set is not None:
${is}    ${followSetVarName} = set(self.${terminal.followSetVarName}) | self.outer_follow_set
    [/#if]
${is}${LHS}self.consume_token(${regexp.label}, ${tolerant}, ${followSetVarName})
  [/#if]
  [#if !terminal.childName?is_null]
${is}if self.build_tree:
${is}    child = self.peek_node()
${is}    name = '${terminal.childName}'
    [#if terminal.multipleChildren]
${is}    ${globals.currentNodeVariableName}.add_to_named_child_list(name, child)
    [#else]
${is}    ${globals.currentNodeVariableName}.set_named_child(name, child)
    [/#if]
  [/#if]
[#-- ${is}# DBG < BuildCodeRegexp ${indent} --]
[/#macro]

[#macro BuildCodeZeroOrOne zoo indent]
[#var is = ""?right_pad(indent)]
[#-- ${is}# DBG > BuildCodeZeroOrOne ${indent} ${zoo.nestedExpansion.class.simpleName} --]
    [#if zoo.nestedExpansion.class.simpleName = "ExpansionChoice"]
${BuildCode(zoo.nestedExpansion, indent)}
    [#else]
${is}if ${ExpansionCondition(zoo.nestedExpansion)}:
${BuildCode(zoo.nestedExpansion, indent + 4)}
    [/#if]
[#-- ${is}# DBG < BuildCodeZeroOrOne ${indent} ${zoo.nestedExpansion.class.simpleName} --]
[/#macro]

[#var inFirstVarName = "", inFirstIndex =0]
[#macro BuildCodeOneOrMore oom indent]
[#var is = ""?right_pad(indent)]
[#-- ${is}# DBG > BuildCodeOneOrMore ${indent} --]
[#var nestedExp=oom.nestedExpansion, prevInFirstVarName = inFirstVarName/]
   [#if nestedExp.simpleName = "ExpansionChoice"]
     [#set inFirstVarName = "inFirst" + inFirstIndex, inFirstIndex = inFirstIndex +1 /]
${is}${inFirstVarName} = True
   [/#if]
${is}while True:
${RecoveryLoop(oom, indent + 4)}
      [#if nestedExp.simpleName = "ExpansionChoice"]
${is}    ${inFirstVarName} = False
      [#else]
${is}    if not (${ExpansionCondition(oom.nestedExpansion)}): break
      [/#if]
   [#set inFirstVarName = prevInFirstVarName /]
[#-- ${is}# DBG < BuildCodeOneOrMore ${indent} --]
[/#macro]

[#macro BuildCodeZeroOrMore zom indent]
[#var is = ""?right_pad(indent)]
[#-- ${is}# DBG > BuildCodeZeroOrMore ${indent} --]
${is}while True:
       [#if zom.nestedExpansion.class.simpleName != "ExpansionChoice"]
${is}    if not (${ExpansionCondition(zom.nestedExpansion)}): break
       [/#if]
       [@RecoveryLoop zom indent+4 /]
[#-- ${is}# DBG < BuildCodeZeroOrMore ${indent} --]
[/#macro]

[#macro RecoveryLoop loopExpansion indent]
[#var is = ""?right_pad(indent)]
[#-- ${is}# DBG > RecoveryLoop ${indent} --]
   [#if !settings.faultTolerant || !loopExpansion.requiresRecoverMethod]
${BuildCode(loopExpansion.nestedExpansion, indent)}
   [#else]
   [#var initialTokenVarName = "initialToken" + CU.newID()]
${is}${initialTokenVarName} = self.last_consumed_token
${is}try:
${BuildCode(loopExpansion.nestedExpansion, indent + 4)}
${is}except ParseException as pe:
${is}    logger.exception('Hit a parsing exception: %s', pe)
${is}    if not self.is_tolerant: raise
${is}    if self.debug_fault_tolerant:
${is}        logger.info('Handling exception. Last consumed token: %s at: %s', self.last_consumed_token.image, self.last_consumed_token.location)
${is}    if ${initialTokenVarName} is self.last_consumed_token:
${is}        self.last_consumed_token = self.next_token(self.last_consumed_token)
${is}        # We have to skip a token in this spot or
${is}        # we'll be stuck in an infinite loop!
${is}        self.last_consumed_token.skipped = True
${is}        if self.debug_fault_tolerant:
${is}            logger.info('Skipping token %s at: %s', self.last_consumed_token.image, self.last_consumed_token.location)
${is}    if self.debug_fault_tolerant:
${is}        logger.info('Repeat re-sync for expansion at: ${loopExpansion.location?j_string}');
${is}    self.${loopExpansion.recoverMethodName}();
${is}    if self.pending_recovery: raise
   [/#if]
[#-- ${is}# DBG < RecoveryLoop ${indent} --]
[/#macro]

[#macro BuildCodeChoice choice indent]
[#var is = ""?right_pad(indent)]
[#-- ${is}# DBG > BuildCodeChoice ${indent} --]
   [#list choice.choices as expansion]
${is}${(expansion_index=0)?string("if", "elif")} (${ExpansionCondition(expansion)}):
${BuildCode(expansion, indent + 4)}
   [/#list]
   [#if choice.parent.simpleName == "ZeroOrMore"]
${is}else:
${is}    break
   [#elseif choice.parent.simpleName = "OneOrMore"]
${is}elif (${inFirstVarName}):
${is}    self.push_onto_call_stack('${currentProduction.name}', '${choice.inputSource?j_string}', ${choice.beginLine}, ${choice.beginColumn})
${is}    raise ParseException(self, expected=self.${choice.firstSetVarName})
${is}else:
${is}    break
   [#elseif choice.parent.simpleName != "ZeroOrOne"]
${is}else:
${is}    self.push_onto_call_stack('${currentProduction.name}', '${choice.inputSource?j_string}', ${choice.beginLine}, ${choice.beginColumn})
${is}    raise ParseException(self, expected=self.${choice.firstSetVarName})
   [/#if]
[#-- ${is}# DBG < BuildCodeChoice ${indent} --]
[/#macro]

[#macro BuildCodeSequence expansion indent]
[#var is = ""?right_pad(indent)]
[#-- ${is}# DBG > BuildCodeSequence ${indent} --]
   [#list expansion.units as subexp]
${BuildCode(subexp, indent)}
   [/#list]
[#-- ${is}# DBG < BuildCodeSequence ${indent} --]
[/#macro]

[#-- The following is a set of utility macros used in multiple expansions. --]

[#--
     Macro to generate the condition for entering an expansion
     including the default single-token lookahead
--]
[#macro ExpansionCondition expansion]
[#if expansion.requiresPredicateMethod]${ScanAheadCondition(expansion)}[#else]${SingleTokenCondition(expansion)}[/#if]
[/#macro]


[#-- Generates code for when we need a scanahead --]
[#macro ScanAheadCondition expansion]
[#if expansion.lookahead?? && expansion.lookahead.LHS??](${expansion.lookahead.LHS} = [/#if][#if expansion.hasSemanticLookahead && !expansion.lookahead.semanticLookaheadNested](${globals.translateExpression(expansion.semanticLookahead)}) and [/#if]self.${expansion.predicateMethodName}()[#if expansion.lookahead?? && expansion.lookahead.LHS??])[/#if]
[/#macro]


[#-- Generates code for when we don't need any scanahead routine --]
[#macro SingleTokenCondition expansion]
[#if expansion.hasSemanticLookahead](${globals.translateExpression(expansion.semanticLookahead)}) and [/#if]
[#if expansion.firstSet.tokenNames?size =0 || expansion.lookaheadAmount ==0 || expansion.minimumSize=0]True[#elseif expansion.firstSet.tokenNames?size < 5][#list expansion.firstSet.tokenNames as name](self.next_token_type == ${name})[#if name_has_next] or [/#if][/#list][#else](self.next_token_type in self.${expansion.firstSetVarName})[/#if]
[/#macro]
