[#ftl strict_vars=true]
/* 
 * Generated by: ${generated_by}. ${filename} ${grammar.copyrightBlurb}
 */
[#var parserPackageWithDot = ""]
[#if grammar.parserPackage?has_content]
package ${grammar.parserPackage};
[/#if]

import java.io.*;
import java.nio.charset.Charset;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharsetDecoder;
import java.nio.charset.CoderResult;
import java.nio.charset.CharacterCodingException;
import static java.nio.charset.StandardCharsets.*;


abstract public class TokenSource
[#if grammar.treeBuildingEnabled]<T extends Node.TerminalNode>
[#else]<T extends Token>[/#if]
{
    /**
     * @return the input source (usually a filename) 
     */
    abstract public String getInputSource();

    /**
     * @return the text between startOffset (inclusive)
     * and endOffset(exclusive)
     */
    abstract public String getText(int startOffset, int endOffset);

    /**
     * @return the line number from the absolute offset passed in as a parameter
     */
    abstract public int getLineFromOffset(int pos);

    /**
     * @return the column (1-based and in code points)
     * from the absolute offset passed in as a parameter
     */
    abstract public int getCodePointColumnFromOffset(int pos);

    abstract void cacheToken(Token token);

  [#if grammar.treeBuildingEnabled]
    abstract T previousCachedToken(int offset);
    abstract T nextCachedToken(int pos);
  [#else]
    abstract Token previousCachedToken(int pos);
    abstract Token nextCachedToken(int pos);
  [/#if]

   /**
    * @param bytes the raw byte array 
    * @param charset The encoding to use to decode the bytes. If this is null, we check for the
    * initial byte order mark (used by Microsoft a lot seemingly)
    * See: https://docs.microsoft.com/es-es/globalization/encoding/byte-order-markc
    * @return A String taking into account the encoding passed in or in the byte order mark (if it was present). 
    * And if no encoding was passed in and no byte-order mark was present, we assume the raw input
    * is in UTF-8.
    */
  static public String stringFromBytes(byte[] bytes, Charset charset) throws CharacterCodingException {
    int arrayLength = bytes.length;
    if (charset == null) {
      int firstByte = arrayLength>0 ? Byte.toUnsignedInt(bytes[0]) : 1;
      int secondByte = arrayLength>1 ? Byte.toUnsignedInt(bytes[1]) : 1;
      int thirdByte = arrayLength >2 ? Byte.toUnsignedInt(bytes[2]) : 1;
      int fourthByte = arrayLength > 3 ? Byte.toUnsignedInt(bytes[3]) : 1;
      if (firstByte == 0xEF && secondByte == 0xBB && thirdByte == 0xBF) {
         return new String(bytes, 3, bytes.length-3, Charset.forName("UTF-8"));
      }
      if (firstByte == 0 && secondByte==0 && thirdByte == 0xFE && fourthByte == 0xFF) {
         return new String(bytes, 4, bytes.length-4, Charset.forName("UTF-32BE"));
      }
      if (firstByte == 0xFF && secondByte == 0xFE && thirdByte == 0 && fourthByte == 0) {
         return new String(bytes, 4, bytes.length-4, Charset.forName("UTF-32LE"));
      }
      if (firstByte == 0xFE && secondByte == 0xFF) {
         return new String(bytes, 2, bytes.length-2, Charset.forName("UTF-16BE"));
      }
      if (firstByte == 0xFF && secondByte == 0xFE) {
         return new String(bytes, 2, bytes.length-2, Charset.forName("UTF-16LE"));
      }
      charset = UTF_8;
    }
    CharsetDecoder decoder = charset.newDecoder();
    ByteBuffer b = ByteBuffer.wrap(bytes);
    CharBuffer c = CharBuffer.allocate(bytes.length);
    while (true) {
        CoderResult r = decoder.decode(b, c, false);
        if (!r.isError()) {
            break;
        }
        if (!r.isMalformed()) {
            r.throwException();
        }
        int n = r.length();
        b.position(b.position() + n);
        for (int i = 0; i < n; i++) {
            c.put((char) 0xFFFD);
        }
    }
    ((Buffer) c).limit(c.position());
    ((Buffer) c).rewind();
    return c.toString();
    // return new String(bytes, charset);
  }

  static public String stringFromBytes(byte[] bytes) throws CharacterCodingException {
     return stringFromBytes(bytes, null);
  }


  static final int BUF_SIZE = 0x10000;

  static public String readFully(Reader reader) throws IOException {
    char[] block = new char[BUF_SIZE];
    int charsRead = reader.read(block);
    if (charsRead < 0) {
        throw new IOException("No input");
    } else if (charsRead < BUF_SIZE) {
        char[] result = new char[charsRead];
        System.arraycopy(block, 0, result, 0, charsRead);
        reader.close();
        return new String(block, 0, charsRead);
    }
    StringBuilder buf = new StringBuilder();
    buf.append(block);
    do {
        charsRead = reader.read(block);
        if (charsRead > 0) {
            buf.append(block, 0, charsRead);
        }
    } while (charsRead == BUF_SIZE);
    reader.close();
    return buf.toString();
  }

// Annoying kludge really...
  static public String readToEnd(Reader reader) {
    try {
        return readFully(reader);
    } catch (IOException ioe) {
        throw new RuntimeException(ioe);
    }
  }

}