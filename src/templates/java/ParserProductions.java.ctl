#-- This template contains the core logic for generating the various parser routines. --

#var nodeNumbering = 0,
     exceptionNesting = 0,
     repetitionIndex = 0,
     NODE_USES_PARSER = settings.nodeUsesParser,
     NODE_PREFIX = grammar.nodePrefix,
     currentProduction,
     treeNodeStack = [],
     topLevelExpansion [#-- A "one-shot" indication that we are processing
                              an expansion immediately below the BNF production expansion,
                              ignoring an ExpansionSequence that might be there. This is
                              primarily, if not exclusively, for allowing JTB-compatible
                              syntactic trees to be built. While seemingly silly (and perhaps could be done differently),
                              it is also a bit tricky, so treat it like the Holy Hand-grenade in that respect.
                          --]

#var inFirstVarName = "",
     choicesVarName = ""

#var jtbNameMap = {
   "Terminal" : "nodeToken",
   "Sequence" : "nodeSequence",
   "Choice" : "nodeChoice",
   "ZeroOrOne" : "nodeOptional",
   "ZeroOrMore" : "nodeListOptional",
   "OneOrMore" : "nodeList" },
   nodeFieldOrdinal = {}

#var injectedFields = {},
     syntheticNodesEnabled = settings.syntheticNodesEnabled && settings.treeBuildingEnabled,
     jtbParseTree = syntheticNodesEnabled && settings.jtbParseTree

#macro Productions
 //====================================================================//
 // Start of methods for BNF Productions                               //
 // This code is generated by the ParserProductions.java.ctl template. //
 //====================================================================//
   #list grammar.parserProductions as production
      #set nodeNumbering = 0
      ${CU.firstSetVar(production.expansion)}
      #if !production.onlyForLookahead
         #set currentProduction = production
         ${ParserProduction(production)}
      #endif
   #endlist
   #if settings.faultTolerant
      ${BuildRecoverRoutines()}
   #endif
#endmacro

#macro ParserProduction production
    #set nodeNumbering = 0,
         repetitionIndex = 0,
         nodeFieldOrdinal = {},
         injectedFields = {}
    #set newVarIndex = 0 in CU
    #-- Generate the method modifiers and header --
    ${production.leadingComments}
// ${production.location}
    final ${production.accessModifier}
    ${production.returnType}
    ${production.name}(${production.parameterList!})
   #if settings.useCheckedException
    throws ParseException
    [#list (production.throwsList.types)! as throw], ${throw}[/#list]
   #elif (production.throwsList.types)??
     #list production.throwsList.types as throw
        #if throw_index == 0
           throws ${throw}
        #else
           , ${throw}
        #endif
     #endlist
   #endif
   #-- Now generate the body --
    {
     if (cancelled) throw new CancellationException();
     this.currentlyParsedProduction = "${production.name}";
     #set topLevelExpansion = false
     ${BuildCode(production)}
    }
#endmacro

[#--
   Macro to build routines that scan up to the start of an expansion
   as part of a recovery routine
--]
#macro BuildRecoverRoutines #-- FIXME:JB this needs to consider cardinality
   #list grammar.expansionsNeedingRecoverMethod as expansion
       private boolean ${expansion.recoverMethodName}(ParseException pe) {
          ${settings.baseTokenClassName} initialToken = lastConsumedToken;
          java.util.List<${settings.baseTokenClassName}> skippedTokens = new java.util.ArrayList<>();
          boolean success = false;
          while (lastConsumedToken.getType() != EOF) {
            #if expansion.simpleName = "OneOrMore" || expansion.simpleName = "ZeroOrMore"
             if (${ExpansionCondition(expansion.nestedExpansion)}) {
            #else
             if (${ExpansionCondition(expansion)}) {
            #endif
                success = true;
                break;
             }
             #if expansion.simpleName = "ZeroOrMore" || expansion.simpleName = "OneOrMore"
               #var followingExpansion = expansion.followingExpansion
               #list 1..1000000 as unused
                #if !followingExpansion
                  #break
                #endif
                #if followingExpansion.maximumSize > 0
                 #if followingExpansion.simpleName = "OneOrMore" || followingExpansion.simpleName = "ZeroOrOne" || followingExpansion.simpleName = "ZeroOrMore"
                 if (${ExpansionCondition(followingExpansion.nestedExpansion)}) {
                 #else
                 if (${ExpansionCondition(followingExpansion)}) {
                 #endif
                    success = true;
                    break;
                 }
                #endif
                #if !followingExpansion.possiblyEmpty
                  #break
                #endif
                #if !followingExpansion.followingExpansion
                 if (outerFollowSet != null) {
                   if (outerFollowSet.contains(nextTokenType())) {
                      success = true;
                      break;
                   }
                 }
                 #break
                #endif
                #set followingExpansion = followingExpansion.followingExpansion
               #endlist
             #endif
             lastConsumedToken = nextToken(lastConsumedToken);
             skippedTokens.add(lastConsumedToken);
          }
          if (!success && !skippedTokens.isEmpty()) {
             lastConsumedToken = initialToken;
          }
          if (success&& !skippedTokens.isEmpty()) {
             InvalidNode iv = new InvalidNode(pe);
             iv.copyLocationInfo(skippedTokens.get(0));
             for (${settings.baseTokenClassName} tok : skippedTokens) {
                iv.add(tok);
                iv.setEndOffset(tok.getEndOffset());
             }
             pushNode(iv);
          }
          return success;
       }
   #endlist
#endmacro

#macro BuildCode expansion cardinalitiesVar
  #if expansion.simpleName != "ExpansionSequence" && expansion.simpleName != "ExpansionWithParentheses"
  // Code for ${expansion.simpleName} specified at ${expansion.location}
  #endif
     [@CU.HandleLexicalStateChange expansion, false, cardinalitiesVar!null]
         #if settings.faultTolerant && expansion.requiresRecoverMethod && !expansion.possiblyEmpty
         if (pendingRecovery) {
            pendingRecovery = !${expansion.recoverMethodName}(null);
         }
         #endif
         ${BuildExpansionCode(expansion, cardinalitiesVar!null)}
     [/@]
#endmacro

#-- The following macro wraps expansions that might build tree nodes. --
#macro TreeBuildingAndRecovery expansion cardinalitiesVar
   #var production,
         treeNodeBehavior,
         buildingTreeNode = false,
         nodeVarName,
         parseExceptionVar = CU.newVarName("parseException"),
         callStackSizeVar = CU.newVarName("callStackSize"),
         canRecover = settings.faultTolerant && expansion.tolerantParsing && expansion.simpleName != "Terminal"
   #set treeNodeBehavior = resolveTreeNodeBehavior(expansion)
   #-- // DBG <> treeNodeBehavior = ${(treeNodeBehavior??)?string!} for expansion ${expansion.simpleName} --
   #if expansion == currentProduction
      #-- Set this expansion as the current production and capture any Java code specified before the first expansion unit --
      #set production = currentProduction
   #endif
   #if treeNodeBehavior??
      #if settings.treeBuildingEnabled
         #set buildingTreeNode = true,
              nodeVarName = nodeVar(production??)
      #endif
   #endif
   #if !buildingTreeNode && !canRecover
      #-- We need neither tree nodes nor recovery code; do the simple one. --
      #nested
   #else
      #-- We need tree nodes and/or recovery code. --
      #if buildingTreeNode
         #-- Build the tree node (part 1).
         #set treeNodeStack = treeNodeStack + [nodeVarName]
         ${createNode(nodeClassName(treeNodeBehavior), nodeVarName)}
      #endif
      ParseException ${parseExceptionVar} = null;
      int ${callStackSizeVar} = parsingStack.size();
      try {
      #if settings.useCheckedException
         if (false) throw new ParseException("Never happens!");
      #endif
         #-- Here is the "nut". --
         #nested
      }
      catch (ParseException ${exceptionVar()}) {
         ${parseExceptionVar} = ${exceptionVar()};
      #if !canRecover
         #if settings.faultTolerant
         if (isParserTolerant()) this.pendingRecovery = true;
         #endif
         throw e;
      #else
         if (!isParserTolerant()) throw e;
         this.pendingRecovery = true;
         // recovery for ${expansion.location}
         ${expansion.recoveryBlock!}
         #-- REVISIT: Something needs to be done about always consuming a token if we get here, or an infinite loop can result.
         #if production?? && production.returnType != "void"
            #var rt = production.returnType
            #-- We need a return statement here or the code won't compile! --
            #if rt = "int" || rt = "char" || rt == "byte" || rt = "short" || rt = "long" || rt = "float"|| rt = "double"
         return 0;
            #elif rt = "boolean"
         return false;
            #else
         return null;
            #endif
         #endif
      #endif
      }
      finally {
         restoreCallStack(${callStackSizeVar});
      #if buildingTreeNode
         #-- Build the tree node (part 2).
         ${buildTreeNodeEpilogue(treeNodeBehavior, nodeVarName, parseExceptionVar)}
         #if treeNodeStack?size > 1
            #set treeNodeStack = treeNodeStack[0..treeNodeStack?size - 2]
         #else
            #set treeNodeStack = []
         #endif
      #endif
      }
   #endif
#endmacro

#function currentNodeVariableName()
  #return treeNodeStack[treeNodeStack?size - 1]
#endfunction

#function imputedJtbFieldName nodeClass
   #if nodeClass?? && jtbParseTree && topLevelExpansion
      #-- Determine the name of the node field containing the reference to a synthetic syntax node --
      #var fieldName = nodeClass?uncap_first,
           fieldOrdinal
      #if jtbNameMap[nodeClass]??
         #-- Allow for JTB-style syntactic node names (but exclude Token and <non-terminal> ). --
         #set fieldName = jtbNameMap[nodeClass]
      #endif
      #set fieldOrdinal = nodeFieldOrdinal[nodeClass]!null
      #if !fieldOrdinal??
         #set nodeFieldOrdinal = nodeFieldOrdinal + {nodeClass : 1}
      #else
         #set nodeFieldOrdinal = nodeFieldOrdinal + {nodeClass : fieldOrdinal + 1}
      #endif
      #var nodeFieldName = fieldName + fieldOrdinal!""
      #-- INJECT <production-node> : { public <field-type> <unique-field-name> } --
      ${injectDeclaration(nodeClass, nodeFieldName)}
      #return nodeFieldName
   #endif
   #-- Indicate that no field name is required (either not JTB or not a top-level production node) --
   #return null
#endfunction

#function resolveTreeNodeBehavior expansion
   #var treeNodeBehavior = expansion.treeNodeBehavior,
        isProduction = false
   #if expansion.simpleName = "BNFProduction"
      #set isProduction = true
   #else
      #var nodeName = syntacticNodeName(expansion) #-- This maps ExpansionSequence containing more than one syntax element to "Sequence", otherwise to the element itself
      #if !treeNodeBehavior?? &&
          expansion.assignment??
         #if syntheticNodesEnabled && isProductionInstantiatingNode(expansion)
            #-- Assignment is explicitly provided and synthetic nodes are enabled --
            [#-- NOTE: An explicit assignment will take precedence over a synthetic JTB node.
               I.e., it will not create a field in the production node.  It WILL, however,
               use the syntactic node type for the natural assignment value, as seen below.
            --]
            #-- This expansion has an explicit assignment; check if we need to synthesize a definite node --
            #if nodeName?? && (
               nodeName == "ZeroOrOne" ||
               nodeName == "ZeroOrMore" ||
               nodeName == "OneOrMore" ||
               nodeName == "Choice" ||
               nodeName == "Sequence"
               )
               #-- We do need to create a definite node --
               #if !jtbParseTree
                  #-- It's not a JTB tree but it is a syntactic node with a LHS assignment, so use the BASE_NODE type --][#-- (jb) is there a reason to use the syntactic type always?  Perhaps, but I can't think of one.
                  #set nodeName = settings.baseNodeClassName
               #endif
               #-- Make a new node to wrap the current expansion with the expansion's assignment. --
               #-- Default to a definite node --
               #var gtNode = false
               #var condition = null
               #var initialShorthand = null
               #if nodeName == "ZeroOrOne" ||
                   nodeName == "ZeroOrMore"
                  #-- Generate an optional node only if at least one child node --
                  #set gtNode = true
                  #set condition = "0"
                  #set initialShorthand = " > "
               #endif
               #set treeNodeBehavior = {
                                          'nodeName' : nodeName,
                                          'condition' : condition,
                                          'gtNode' : gtNode,
                                          'initialShorthand' : initialShorthand,
                                          'void' : false,
                                          'assignment' : expansion.assignment
                                       }
               #if expansion.assignment.propertyAssignment && expansion.assignment.declarationOf
                  #-- Inject the receiving property --
                  ${injectDeclaration(nodeName, expansion.assignment.name, expansion.assignment)}
               #endif
            #endif
         #elif nodeName??
            #-- We are attempting to do assignment of a syntactic node value, but synthetic nodes are not enabled --
            #exec grammar.errors::addWarning(currentProduction, "Attempt to assign " + nodeName + " in production node " + currentProduction.name + " but either synthetic nodes are not enabled or the production is not instantiated; the assignment will be ignored.")
            #return null
         #endif
      #elif treeNodeBehavior?? &&
               treeNodeBehavior.assignment??
         #-- There is an explicit tree node annotation with assignment; make sure a property is injected if needed. --
         #if treeNodeBehavior.assignment.declarationOf
            ${injectDeclaration(treeNodeBehavior.nodeName, treeNodeBehavior.assignment.name, treeNodeBehavior.assignment)}
         #endif
         #if jtbParseTree
           #exec grammar.errors::addWarning(currentProduction, "Attempt to assign " + nodeName + " in production node " + currentProduction.name + " but it is an implicit JTB syntactic node.")
         #endif
      #elif jtbParseTree &&
              expansion.parent.simpleName != "ExpansionWithParentheses" &&
              isProductionInstantiatingNode(currentProduction)
         #-- No in-line definite node annotation; synthesize a parser node for the expansion type being built, if needed. --
         #if nodeName??
            #-- Determine the node name depending on syntactic type --
            #var nodeFieldName = imputedJtbFieldName(nodeName) #-- Among other things this injects the node field into the generated node if result is non-nullv
            #-- Default to a definite node --
            #var gtNode = false
            #var condition = null
            #var initialShorthand = null
            #if nodeName == "Choice"
               #-- Generate a Choice node only if at least one child node --
               #set gtNode = true
               #set condition = "0"
               #set initialShorthand = " > "
            #endif
            #if nodeFieldName??
               [#-- Provide an assignment to save the syntactic node in a
               synthetic field injected into the actual production node per JTB behavior. --]
               #set treeNodeBehavior = {
                                          'nodeName' : nodeName!"nemo",
                                          'condition' : condition,
                                          'gtNode' : gtNode,
                                          'initialShorthand' : initialShorthand,
                                          'void' : false,
                                          'assignment' :
                                             { 'name' : globals::translateIdentifier("THIS_PRODUCTION") + "." + nodeFieldName,
                                               'propertyAssignment' : false,
                                               'declarationOf' : true,
                                               'existenceOf' : false }
                                       }
            #else
               #-- Just provide the syntactic node with no LHS needed --
               #set treeNodeBehavior = {
                                          'nodeName' : nodeName!"nemo",
                                          'condition' : condition,
                                          'gtNode' : gtNode,
                                          'initialShorthand' : initialShorthand,
                                          'void' : false,
                                          'assignment' : null
                                       }
            #endif
         #endif
      #endif
   #endif
   #if !treeNodeBehavior??
      #-- There is still no treeNodeBehavior determined; supply the default if this is a BNF production node. No assignment is needed. --
      #if isProduction && !settings.nodeDefaultVoid
                        && !grammar::nodeIsInterface(expansion.name)
                        && !grammar::nodeIsAbstract(expansion.name)
         #if settings.smartNodeCreation
            #set treeNodeBehavior = {
                                       "nodeName" : expansion.name!"nemo",
                                       "condition" : "1",
                                       "gtNode" : true,
                                       "void" :false,
                                       "initialShorthand" : ">",
                                       'assignment' : null
                                     }
         #else
            #set treeNodeBehavior = {
                                       "nodeName" : expansion.name!"nemo",
                                       "condition" : null,
                                       "gtNode" : false,
                                       "void" : false,
                                       'assignment' : null
                                    }
         #endif
      #endif
   #endif
   #if treeNodeBehavior?? && treeNodeBehavior.neverInstantiated?? && treeNodeBehavior.neverInstantiated
      #-- Now, if the treeNodeBehavior says it will never be instantiated, throw it all away --
      #return null
   #endif
   #-- This is the actual treeNodeBehavior for this node --
   #return treeNodeBehavior
#endfunction

#-- This is primarily to distinguish sequences of syntactic elements from effectively single elements --
#function syntacticNodeName expansion
      #var classname = expansion.simpleName
      #if classname = "ZeroOrOne"
         #return classname
      #elif classname = "ZeroOrMore"
         #return classname
      #elif classname = "OneOrMore"
         #return classname
      #elif jtbParseTree && classname = "Terminal"
         #return classname
      #elif classname = "ExpansionChoice"
         #return "Choice"
      #elif classname = "ExpansionWithParentheses" || classname = "BNFProduction"
         #-- the () will be skipped and the nested expansion processed, so built the tree node for it rather than this --
         #var innerExpansion = expansion.nestedExpansion
         #return syntacticNodeName(innerExpansion)
      #elif classname = "ExpansionSequence" &&
               expansion.parent?? &&
               (
                  expansion.parent.simpleName == "ExpansionWithParentheses" ||
                  (
                     expansion.parent.simpleName == "ZeroOrOne" ||
                     expansion.parent.simpleName == "OneOrMore" ||
                     expansion.parent.simpleName == "ZeroOrMore" ||
                     expansion.parent.simpleName == "ExpansionChoice"
                  ) && expansion.essentialSequence
               )
         #return "Sequence"
      #endif
      #return null
#endfunction

#function isProductionInstantiatingNode expansion
   #return !expansion.containingProduction.treeNodeBehavior?? ||
           !expansion.containingProduction.treeNodeBehavior.neverInstantiated!true
#endfunction

#function nodeVar isProduction
   #var nodeVarName
   #if isProduction
      #set nodeVarName = globals::translateIdentifier("THIS_PRODUCTION")
   #else
      #set nodeNumbering = nodeNumbering + 1
      #set nodeVarName = currentProduction.name + nodeNumbering
   #endif
   #return nodeVarName
#endfunction

#function exceptionVar(isNesting)
   #var exceptionVarName = "e"
   #if exceptionNesting > 0
      #set exceptionVarName = "e" + exceptionNesting
   #endif
   #if isNesting!false
      #set exceptionNesting = exceptionNesting + 1
   #endif
   #return exceptionVarName
#endfunction

#--  Boilerplate code to create the node variable --
#macro createNode nodeClass nodeVarName
#-- // DBG > createNode --
   ${nodeClass}
   ${nodeVarName} = null;
   if (buildTree) {
      ${nodeVarName} = new ${nodeClass}();
   #if settings.nodeUsesParser
      ${nodeVarName}.setParser(this);
   #endif
        openNodeScope(${nodeVarName});
   }
#-- // DBG < createNode --
#endmacro

#macro buildTreeNodeEpilogue treeNodeBehavior nodeVarName parseExceptionVar
   if (${nodeVarName} != null) {
      if (${parseExceptionVar} == null) {
   #if treeNodeBehavior?? && treeNodeBehavior.assignment??
      #var LHS = getLhsPattern(treeNodeBehavior.assignment, null)
         if (closeNodeScope(${nodeVarName}, ${closeCondition(treeNodeBehavior)})) {
            ${LHS?replace("@", "(" + nodeClassName(treeNodeBehavior) + ") peekNode()")};
         } else{
            ${LHS?replace("@", "null")};
         }
   #else
         closeNodeScope(${nodeVarName}, ${closeCondition(treeNodeBehavior)});
   #endif
   #list grammar.closeNodeHooksByClass[nodeClassName(treeNodeBehavior)]! as hook
         ${hook}(${nodeVarName});
   #endlist
      } else {
   #if settings.faultTolerant
         closeNodeScope(${nodeVarName}, true);
         ${nodeVarName}.setDirty(true);
   #else
         clearNodeScope();
   #endif
      }
   }
#endmacro

#function getRhsAssignmentPattern assignment
   #if assignment.existenceOf!false
      #-- replace "@" with "(((@) != null) ? true : false)" --
      #return "(((@) != null) ? true : false)"
   #elif assignment.stringOf!false
      #-- replace "@" with the string value of the node
      #return "Objects.toString((@), \"\").trim()"
   #endif
   #return "@"
#endfunction

#function getLhsPattern assignment, lhsType
   #if assignment??
      #var lhsName = assignment.name
      #if assignment.propertyAssignment
         #-- This is the assignment of the current node's effective value to a property of the production node --
         #set lhsName = lhsName?cap_first
         #if lhsType?? && assignment.declarationOf
            #-- This is a declaration assignment; inject required property --
            ${injectDeclaration(lhsType, assignment.name, assignment)}
         #endif
         #if assignment.addTo!false
            #-- This is the addition of the current node as a child of the specified property's node value --
            #return globals::translateIdentifier("THIS_PRODUCTION") + ".get" + lhsName + "().add(" + getRhsAssignmentPattern(assignment) + ")"
         #else
            #-- This is an assignment of the current node's effective value to the specified property of the production node --
            #return globals::translateIdentifier("THIS_PRODUCTION") + ".set" + lhsName + "(" + getRhsAssignmentPattern(assignment) + ")"
         #endif
      #elif assignment.namedAssignment!false
         #if assignment.addTo
            #-- This is the addition of the current node to the named child list of the production node --
            #return "${currentNodeVariableName()}" + ".addToNamedChildList(\"" + lhsName + "\", " + getRhsAssignmentPattern(assignment) + ")"
         #else
            #-- This is an assignment of the current node to a named child of the production node --
            #return "${currentNodeVariableName()}" + ".setNamedChild(\"" + lhsName + "\", " + getRhsAssignmentPattern(assignment) + ")"
         #endif
      #endif
      #-- This is the assignment of the current node or it's returned value to an arbitrary LHS "name" (i.e., the legacy JavaCC assignment) --
      #return lhsName + " = " + getRhsAssignmentPattern(assignment)
   #endif
   #-- There is no LHS --
   #return "@"
#endfunction

#function injectDeclaration typeName, fieldName, assignment
   #if !isProductionInstantiatingNode(currentProduction)
      #exec grammar.errors::addWarning(currentProduction, "Attempt to inject property or field declaration " + fieldName + " into an un-instantiated production node " + currentProduction.name + "; the assignment will be ignored.")
      #return ""
   #endif
   #var modifier = "public",
        type = typeName,
        field = fieldName
   #if assignment?? && assignment.propertyAssignment
      #set modifier = "@Property"
   #endif
   #if assignment?? && assignment.existenceOf
      #set type = "boolean"
   #elif assignment?? && assignment.stringOf
      #set type = "String"
   #elif assignment?? && assignment.addTo
      #set type = "List<Node>"
      #set field = field + " = new ArrayList<Node>()"
   #endif
   #if !(injectedFields[field])??
      #set injectedFields = injectedFields + {field : type}
      #exec grammar::addFieldInjection(currentProduction.nodeName, modifier, type, field)
   #endif
   #return ""
#endfunction

#function closeCondition treeNodeBehavior
   #var cc = "true"
   #if (treeNodeBehavior.condition)??
         #set cc = treeNodeBehavior.condition
         #if treeNodeBehavior.gtNode
            #set cc = "nodeArity() " + treeNodeBehavior.initialShorthand  + cc
         #endif
   #endif
   #return cc
#endfunction

#function nodeClassName treeNodeBehavior
   #if treeNodeBehavior?? && treeNodeBehavior.nodeName??
      #return NODE_PREFIX + treeNodeBehavior.nodeName
   #endif
   #return NODE_PREFIX + currentProduction.name
#endfunction

#macro BuildExpansionCode expansion cardinalitiesVar
   #var classname = expansion.simpleName
   #var prevLexicalStateVar = CU.newVarName("previousLexicalState")
   #-- take care of the non-tree-building classes --
   #if classname = "CodeBlock"
      ${expansion}
   #elif classname = "RawCode"
      ${expansion.rawContent}
   #elif classname = "UncacheTokens"
         uncacheTokens();
   #elif classname = "Failure"
      ${BuildCodeFailure(expansion)}
   #elif classname = "Assertion"
      #if expansion.appliesInRegularParsing
        ${BuildAssertionCode(expansion, cardinalitiesVar)}
      #endif
   #elif classname = "TokenTypeActivation"
      ${BuildCodeTokenTypeActivation(expansion)}
   #elif classname = "TryBlock"
      ${BuildCodeTryBlock(expansion, cardinalitiesVar)}
   #elif classname = "AttemptBlock"
      ${BuildCodeAttemptBlock(expansion, cardinalitiesVar)}
   #else
      #-- take care of the tree node (if any) --
      [@TreeBuildingAndRecovery expansion]
         #if classname = "BNFProduction"
            #-- The tree node having been built, now build the actual top-level expansion --
            #set topLevelExpansion = true
            ${BuildCode(expansion.nestedExpansion, cardinalitiesVar)}
         #else
            #-- take care of terminal and non-terminal expansions; they cannot contain child expansions --
            #if classname = "NonTerminal"
               ${BuildCodeNonTerminal(expansion)}
            #elif classname = "Terminal"
               ${BuildCodeTerminal(expansion)}
            #else
               #-- take care of the syntactical expansions (which can contain child expansions) --
               #-- capture the top-level indication in order to restore when bubbling up --
               #var stackedTopLevel = topLevelExpansion
               #if topLevelExpansion && classname != "ExpansionSequence"
                  #-- turn off top-level indication unless an expansion sequence (the tree node has already been determined when this nested template is expanded) --
                  #set topLevelExpansion = false
               #endif
               #if classname = "ZeroOrOne"
                  ${BuildCodeZeroOrOne(expansion, cardinalitiesVar)}
               #elif classname = "ZeroOrMore"
                  ${BuildCodeZeroOrMore(expansion)}
               #elif classname = "OneOrMore"
                  ${BuildCodeOneOrMore(expansion)}
               #elif classname = "ExpansionChoice"
                  ${BuildCodeChoice(expansion, cardinalitiesVar)}
               #elif classname = "ExpansionWithParentheses"
                  #-- Recurse; the real expansion is nested within this one (but the LHS, if any, is on the parent)
                  ${BuildExpansionCode(expansion.nestedExpansion, cardinalitiesVar)}
               #elif classname = "ExpansionSequence"
                  ${BuildCodeSequence(expansion, cardinalitiesVar)} #-- leave the topLevelExpansion one-shot alone (see above)
               #endif
               #set topLevelExpansion = stackedTopLevel
            #endif
         #endif
      [/@TreeBuildingAndRecovery]
   #endif
#endmacro

#-- The following macros build expansions that never build tree nodes. --

#macro BuildCodeFailure fail
    #if !fail.code??
      pushOntoCallStack("${fail.containingProduction.name}",
                        "${fail.inputSource?j_string}",
                        ${fail.beginLine}, ${fail.beginColumn});
      #if fail.exp??
       fail("Failure: " + ${fail.exp}, getToken(1));
      #else
       fail("Failure", getToken(1));
      #endif
    #else
       ${fail.code}
    #endif
#endmacro

#macro BuildAssertionCode assertion cardinalitiesVar
   #var optionalPart = ""
   #if assertion.messageExpression??
      #set optionalPart = " + " + assertion.messageExpression
   #endif
   #var assertionMessage = "Assertion at: " + assertion.location?j_string + " failed. "
   #if assertion.assertionExpression??
      if (!(${assertion.assertionExpression})) {
         pushOntoCallStack("${assertion.containingProduction.name}",
                        "${assertion.inputSource?j_string}",
                        ${assertion.beginLine}, ${assertion.beginColumn});
         fail("${assertionMessage}"${optionalPart},
              ${assertion.locationExpression!"getToken(1)"});
      }
   #elseif assertion.cardinalityConstraint??
      if (!${cardinalitiesVar!"cardinalities"}.choose(${assertion.assertionIndex}, false)) {
         fail("Maximum cardinality constraint at: ${assertion.location?j_string} exceeded.", getToken(1));
      }
   #endif
   #if assertion.expansion??
      if ( [#if !assertion.expansionNegated]![/#if]
      ${assertion.expansion.scanRoutineName}()) {
         pushOntoCallStack("${assertion.containingProduction.name}",
                        "${assertion.inputSource?j_string}",
                        ${assertion.beginLine}, ${assertion.beginColumn});
         fail("${assertionMessage}"${optionalPart},
             ${assertion.locationExpression!"getToken(1)"});
      }
   #endif
#endmacro

#macro BuildCodeTokenTypeActivation activation
    #if activation.deactivate
       deactivateTokenTypes(
    #else
       activateTokenTypes(
    #endif
    #list activation.tokenNames as name
       ${name} [#if name_has_next],[/#if]
    #endlist
       );
#endmacro

#macro BuildCodeTryBlock tryblock cardinalitiesVar
     try {
        ${BuildCode(tryblock.nestedExpansion, cardinalitiesVar)}
     }
   #list tryblock.catchBlocks as catchBlock
     ${catchBlock}
   #endlist
     ${tryblock.finallyBlock!}
#endmacro

#macro BuildCodeAttemptBlock attemptBlock cardinalitiesVar
   #-- REVISIT: Cardinality assertions are currently not allowed (sanity check) within the ATTEMPT block, but this could be relaxed --
   try {
      stashParseState(${cardinalitiesVar!""});
      ${BuildCode(attemptBlock.nestedExpansion, cardinalitiesVar)}
      popParseState();
   }
   #var pe = exceptionVar(true)
   catch (ParseException ${pe}) {
      #if cardinalitiesVar??
         ${cardinalitiesVar} =
      #endif
      restoreStashedParseState();
      #-- The recover block may never contain cardinality assertions!!! --
      ${BuildCode(attemptBlock.recoveryExpansion)}
      #set exceptionNesting = exceptionNesting - 1
   }
#endmacro

#-- The following macros build expansions that might build tree nodes (could be called "syntactic" nodes). --

#macro BuildCodeNonTerminal nonterminal
   pushOntoCallStack("${nonterminal.containingProduction.name}", "${nonterminal.inputSource?j_string}", ${nonterminal.beginLine}, ${nonterminal.beginColumn});
   #if settings.faultTolerant
      #var followSet = nonterminal.followSet
      #if !followSet.incomplete
         #if !nonterminal.beforeLexicalStateSwitch
            outerFollowSet = ${nonterminal.followSetVarName};
         #else
            outerFollowSet = null;
         #endif
      #elif !followSet.empty
         if (outerFollowSet != null) {
            EnumSet<TokenType> newFollowSet = ${nonterminal.followSetVarName}.clone();
            newFollowSet.addAll(outerFollowSet);
            outerFollowSet = newFollowSet;
         }
      #endif
   #endif
   try {
      ${AcceptNonTerminal(nonterminal)}
   }
   finally {
       popCallStack();
   }
#endmacro

#macro AcceptNonTerminal nonterminal
   #var lhsClassName = nonterminal.production.nodeName,
        expressedLHS = getLhsPattern(nonterminal.assignment,lhsClassName),
        impliedLHS = "@"
   #if jtbParseTree && isProductionInstantiatingNode(nonterminal.production) && topLevelExpansion
      #set impliedLHS = globals::translateIdentifier("THIS_PRODUCTION") + "." + imputedJtbFieldName(nonterminal.production.nodeName) + " = @"
   #endif
   #-- Accept the non-terminal expansion --
   #if nonterminal.production.returnType != "void" && expressedLHS != "@" && !nonterminal.assignment.namedAssignment && !nonterminal.assignment.propertyAssignment
      #-- Not a void production, so accept and clear the expressedLHS, it has already been applied. --
      ${expressedLHS?replace("@", nonterminal.name + "(" + nonterminal.args! + ")")};
      #set expressedLHS = "@"
   #else
      ${nonterminal.name}(${nonterminal.args!});
   #endif
   #if expressedLHS != "@" || impliedLHS != "@"
      #if nonterminal.assignment?? && (nonterminal.assignment.addTo!false || nonterminal.assignment.namedAssignment)
         if (buildTree) {
            #if impliedLHS == "@"
               ${expressedLHS?replace("@", impliedLHS?replace("@", "peekNode()"))};
            #else
               ${expressedLHS?replace("@", impliedLHS?replace("@", "(" + nonterminal.production.nodeName + ") peekNode()"))};
            #endif
         }
      #else
         try {
            #-- There had better be a node here! --
            ${expressedLHS?replace("@", impliedLHS?replace("@", "(" + nonterminal.production.nodeName + ") peekNode()"))};
         } catch (ClassCastException cce) {
            ${expressedLHS?replace("@", impliedLHS?replace("@", "null"))};
         }
      #endif
   #endif
#endmacro

#macro BuildCodeTerminal terminal
   #var LHS = getLhsPattern(terminal.assignment, "Token"), regexp = terminal.regexp
   #var lambda = terminal.recoveryBlock!
   #if !settings.faultTolerant
       pushOntoCallStack("${currentProduction.name}","${terminal.inputSource?j_string}", ${terminal.beginLine}, ${terminal.beginColumn});
       try {
           ${LHS?replace("@", "consumeToken(" + regexp.label + ")")};
       }
       finally {
         popCallStack();
       }
   #else
       #var tolerant = terminal.tolerantParsing?string("true", "false"),
            followSetVarName = terminal.followSetVarName
       #if terminal.followSet.incomplete
         #set followSetVarName = "followSet" + CU.newID()
         EnumSet<TokenType> ${followSetVarName} = null;
         if (outerFollowSet != null) {
            ${followSetVarName} = ${terminal.followSetVarName}.clone();
            ${followSetVarName}.addAll(outerFollowSet);
         }
       #endif
       pushOntoCallStack("${currentProduction.name}","${terminal.inputSource?j_string})", ${terminal.beginLine}, ${terminal.endLine});
       try {
           ${LHS?replace("@", "consumeToken(" + regexp.label + ", " + tolerant + ", " + followSetVarName + ", () -> {" + lambda + ";})")};
       }
       finally {
         popCallStack();
       }
   #endif
#endmacro

#macro BuildCodeZeroOrOne zoo cardinalitiesVar
    #if zoo.nestedExpansion.class.simpleName = "ExpansionChoice"
       ${BuildCode(zoo.nestedExpansion, cardinalitiesVar)}
    #else
       if (${ExpansionCondition(zoo.nestedExpansion, cardinalitiesVar)}) {
          ${BuildCode(zoo.nestedExpansion, cardinalitiesVar)}
       }
    #endif
#endmacro

#var inFirstIndex = 0

#macro BuildCodeOneOrMore oom
   #var nestedExp = oom.nestedExpansion, prevInFirstVarName = inFirstVarName
   #if nestedExp.simpleName = "ExpansionChoice"
     #set inFirstVarName = "inFirst" + inFirstIndex, inFirstIndex = inFirstIndex + 1
     boolean ${inFirstVarName} = true;
   #endif
   #var cardinalitiesVar = null
   #if oom.cardinalityContainer
      #set cardinalitiesVar = "cardinalities" + repetitionIndex
      #set repetitionIndex = repetitionIndex + 1
      RepetitionCardinality ${cardinalitiesVar} = new RepetitionCardinality(${CU.BuildCardinalities(oom.cardinalityConstraints)});
   #endif
   while (true) {
     ${RecoveryLoop(oom, cardinalitiesVar)} [#-- REVISIT: recovery of cardinalities!!! --]
     #if oom.cardinalityContainer
       ${cardinalitiesVar}.commitIteration(true);
     #endif
     #if nestedExp.simpleName = "ExpansionChoice"
       ${inFirstVarName} = false;
     #else
       if (!(${ExpansionCondition(oom.nestedExpansion, cardinalitiesVar)})) break;
     #endif
   }
   #if oom.minCardinalityConstrained
      if (!${cardinalitiesVar}.checkCardinality(false))  {
         fail("Minimum cardinality constraint(s) for: ${oom.location?j_string} not met.", getToken(1));
      }
   #endif
   #set inFirstVarName = prevInFirstVarName
#endmacro

#macro BuildCodeZeroOrMore zom
   #var cardinalitiesVar = null
   #if zom.cardinalityContainer
      #set cardinalitiesVar = "cardinalities" + repetitionIndex
      #set repetitionIndex = repetitionIndex + 1
      RepetitionCardinality ${cardinalitiesVar} = new RepetitionCardinality(${CU.BuildCardinalities(zom.cardinalityConstraints)});
   #endif
   while (true) {
      #if zom.nestedExpansion.class.simpleName != "ExpansionChoice"
         if (!(${ExpansionCondition(zom.nestedExpansion, cardinalitiesVar)})) break;
      #endif
      ${RecoveryLoop(zom, cardinalitiesVar)}
      #if zom.cardinalityContainer
         ${cardinalitiesVar}.commitIteration(true);
      #endif
   }
   #if zom.minCardinalityConstrained
      if (!${cardinalitiesVar}.checkCardinality(false))  {
         fail("Minimum cardinality constraint(s) for: ${zom.location?j_string} not met.", getToken(1));
      }
   #endif
#endmacro

#macro RecoveryLoop loopExpansion cardinalitiesVar
   #if !settings.faultTolerant || !loopExpansion.requiresRecoverMethod
       ${BuildCode(loopExpansion.nestedExpansion, cardinalitiesVar)}
   #else
       #var initialTokenVarName = "initialToken" + CU.newID()
       ${settings.baseTokenClassName} ${initialTokenVarName} = lastConsumedToken;
       try {
          ${BuildCode(loopExpansion.nestedExpansion, cardinalitiesVar)}
       } catch (ParseException pe) {
          if (!isParserTolerant()) throw pe;
          if (${initialTokenVarName} == lastConsumedToken) {
             lastConsumedToken = nextToken(lastConsumedToken);
             //We have to skip a token in this spot or
             // we'll be stuck in an infinite loop!
             lastConsumedToken.setSkipped(true);
          }
          if (${loopExpansion.recoverMethodName}(pe)) {
             #if loopExpansion.recoveryBlock??
                 // Recovery code action at ${loopExpansion.recoveryBlock.location} when recovery succeeded and pushed an InvalidNode
                 ${loopExpansion.recoveryBlock.javaCode}
             /#if
             pendingRecovery = false;
          }
          if (pendingRecovery) throw pe;
       }
   #endif
#endmacro

#macro BuildCodeChoice choice cardinalitiesVar
   #list choice.choices as expansion
      #if expansion.enteredUnconditionally
        {
         ${BuildCode(expansion, cardinalitiesVar)}
         #if jtbParseTree && isProductionInstantiatingNode(expansion)
            ${currentNodeVariableName()}.setChoice(${expansion_index});
         #endif
        }
        #if expansion_has_next
            #var nextExpansion = choice[expansion_index + 1]
            // Warning: choice at ${nextExpansion.location} is ignored because the
            // choice at ${expansion.location} is entered unconditionally and we jump
            // out of the loop..
        #endif
        #return
      #endif
      if (${ExpansionCondition(expansion, cardinalitiesVar)}) {
         ${BuildCode(expansion, cardinalitiesVar)}
         #if jtbParseTree && isProductionInstantiatingNode(expansion)
            ${currentNodeVariableName()}.setChoice(${expansion_index});
         #endif
      }
      #if expansion_has_next
         else
      #endif
   #endlist
   #if choice.parent.simpleName = "ZeroOrMore"
      else {
         break;
      }
   #elif choice.parent.simpleName = "OneOrMore"
       else if (${inFirstVarName}) {
           pushOntoCallStack("${currentProduction.name}", "${choice.inputSource?j_string}", ${choice.beginLine}, ${choice.beginColumn});
           throw new ParseException(getToken(1), ${choice.firstSetVarName}, parsingStack);
       } else {
           break;
       }
   #elif choice.parent.simpleName != "ZeroOrOne"
       else {
           pushOntoCallStack("${currentProduction.name}", "${choice.inputSource?j_string}", ${choice.beginLine}, ${choice.beginColumn});
           throw new ParseException(getToken(1), ${choice.firstSetVarName}, parsingStack);
        }
   #endif
#endmacro

#macro BuildCodeSequence expansion cardinalitiesVar
       #list expansion.units as subexp
           ${BuildCode(subexp, cardinalitiesVar)}
       #endlist
#endmacro

#-- The following is a set of utility macros used in expansion expansions.

[#--
     Macro to generate the condition for entering an expansion
     including the default single-token lookahead
--]
#macro ExpansionCondition expansion cardinalitiesVar
    #if expansion.requiresPredicateMethod
       ${ScanAheadCondition(expansion, cardinalitiesVar!null)}
    #else
       ${SingleTokenCondition(expansion, cardinalitiesVar!null)}
    #endif
#endmacro

#-- Generates code for when we need a scanahead --
#macro ScanAheadCondition expansion cardinalitiesVar
   #if expansion.lookahead?? && expansion.lookahead.assignment??
      (${expansion.lookahead.assignment.name} =
   #endif
   #if expansion.hasSemanticLookahead && !expansion.lookahead.semanticLookaheadNested
      (${expansion.semanticLookahead}) &&
   #endif
   #if expansion.cardinalityConstrained && cardinalitiesVar??
      ${expansion.predicateMethodName}(${cardinalitiesVar})
   #else
      ${expansion.predicateMethodName}()
   #endif
   #if expansion.lookahead?? && expansion.lookahead.assignment??
      )
   #endif
#endmacro


#-- Generates code for when we don't need any scanahead routine. --
#macro SingleTokenCondition expansion cardinalitiesVar [#-- JB:REVISIT probably don't need this arg here --]
   #if expansion.hasSemanticLookahead
      (${expansion.semanticLookahead}) &&
   #endif
   #if expansion.firstSet.tokenNames?size < CU.USE_FIRST_SET_THRESHOLD
      #list expansion.firstSet.tokenNames as name
          typeMatches(${name}, getToken(1))
          ${name_has_next ?: "||"}
      #endlist
   #else
      hasMatch(${expansion.firstSetVarName}, getToken(1))
   #endif
#endmacro
