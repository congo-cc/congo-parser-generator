ENSURE_FINAL_EOL;
JAVA_UNICODE_ESCAPE;
PARSER_PACKAGE=org.congocc.parser;
NODE_PACKAGE=org.congocc.parser.tree;
DEFAULT_LEXICAL_STATE=JAVA;
BASE_SRC_DIR="../java";
TOKEN_CHAINING;

DEACTIVATE_TOKENS=_INCLUDE,_INJECT,_EOF;

//FAULT_TOLERANT=true;

INJECT LEXER_CLASS : 
{
  // Set whether to generate unparsed tokens for WHITESPACE
  static public void keepWhitespace(boolean b) {
    if (b) {
        skippedTokens.remove(WHITESPACE);
        unparsedTokens.add(WHITESPACE);
    } else {
        skippedTokens.add(WHITESPACE);
        unparsedTokens.remove(WHITESPACE);
    }
  }
}

INJECT PARSER_CLASS :
    import java.util.*;
    import org.congocc.*;
    import org.congocc.core.*;
    import org.congocc.parser.tree.*;
    import org.congocc.preprocessor.PreprocessorParser;
{
    Grammar grammar;
    
    public PARSER_CLASS(Grammar grammar, Path path, Map<String, String> definedSymbols) throws IOException {
        this(path.toString(), path);
        this.grammar = grammar;
        BitSet lineMarkers = null;
        try {
            PreprocessorParser ppp = new PreprocessorParser(path, definedSymbols);
            lineMarkers = ppp.PP_Root();
        } catch (org.congocc.preprocessor.ParseException pe) {
            throw new RuntimeException(pe);
        }
        token_source.setParsedLines(lineMarkers);
    }

    public PARSER_CLASS(Grammar grammar, String inputSource, CharSequence content) {
         this(inputSource, content);
         this.grammar = grammar;
         BitSet lineMarkers = null;
         try {
             lineMarkers = new PreprocessorParser(content).PP_Root();
         } catch(org.congocc.preprocessor.ParseException pe) {
             throw new RuntimeException(pe);
         }
         token_source.setParsedLines(lineMarkers);
    }
    
    static public CompilationUnit parseJavaFile(String inputSource, CharSequence content) throws ParseException {
        PARSER_CLASS parser = new PARSER_CLASS(inputSource, content);
        return parser.CompilationUnit();
    }

    static public CompilationUnit parseJavaFile(Path path) throws ParseException, IOException {
        PARSER_CLASS parser = new PARSER_CLASS(path);
        return parser.CompilationUnit();
    }

    public Grammar getGrammar() {
        return grammar;
    }
    
    public void openNodeScopeHook(Node n) {
        n.setGrammar(grammar);
    }

}

/* congocc RESERVED WORDS: These are the only tokens in congocc but not in Java */

TOKEN :
  < _INJECT: "INJECT" > #CongoCCKeyWord
  |
  < _INCLUDE : "INCLUDE" | "INCLUDE_GRAMMAR"> #CongoCCKeyWord
  |
  < _FAIL : "FAIL" > #CongoCCKeyWord
  |
  < _UNCACHE_TOKENS : "UNCACHE_TOKENS"> #CongoCCKeyWord
  |
  < _ACTIVE_TOKENS : "ACTIVE_TOKENS"> #CongoCCKeyWord
  |
  < _ACTIVATE_TOKENS : "ACTIVATE_TOKENS"> #CongoCCKeyWord
  |
  < _DEACTIVATE_TOKENS : "DEACTIVATE_TOKENS"> #CongoCCKeyWord
  |
  < _ENSURE : "ASSERT"> #CongoCCKeyWord
  |
  < _SCAN : "SCAN" > #CongoCCKeyWord
  |
  < _IGNORE_CASE: "IGNORE_CASE" > #CongoCCKeyWord
  |
  < _TOKEN: "TOKEN" | "REGULAR_TOKEN"> #CongoCCKeyWord
  |
  < _UNPARSED: "SPECIAL_TOKEN" | "UNPARSED" > #CongoCCKeyWord
  |
  < _MORE: "MORE" | "INCOMPLETE_TOKEN" > #CongoCCKeyWord
  |
  < _SKIP: "SKIP" > #CongoCCKeyWord
  |
  <_EOF : "EOF"> #CongoCCKeyWord
  |
  < _ATTEMPT: "ATTEMPT"> #CongoCCKeyWord
  |
  < _RECOVER : "RECOVER"> #CongoCCKeyWord
  |
  < _RECOVER_TO : "RECOVER_TO"> #CongoCCKeyWord
  |
  < _ON_ERROR : "ON_ERROR"> #CongoCCKeyWord
  |
  <HASH : "#">
  |
  <BACKSLASH : "\\"> #Backslash
  |
  <RIGHT_ARROW : "=>"> #RightArrow
  |
  <UP_TO_HERE : "=>|" ("|" | ("+" ["0"-"9"]))> 
  |
  <_LEXICAL_STATE : "LEXICAL_STATE"> #CongoCCKeyWord
  |
  <SINGLE_QUOTE_STRING:
      "'"
      (
          ~["'","\\","\n","\r"]
          |
          <STRING_ESCAPE>
      ){2,}
       "'"
  > #StringLiteral
  |
  <START_UNPARSED : "{$" > : IN_UNPARSED_CODE_BLOCK
;

<IN_UNPARSED_CODE_BLOCK> TOKEN : 
  <UNPARSED_CONTENT : (~["$"] | (("$")+ ~["}"]))+ > #UnparsedContent
  |
  <END_UNPARSED : "$}" > : JAVA
;

UnparsedCodeBlock #org.congocc.core.UnparsedCodeBlock : 
   <START_UNPARSED> 
   [<UNPARSED_CONTENT>]
   <END_UNPARSED>
;

//INJECT UnparsedCodeBlock : extends org.congocc.core.EmptyExpansion

INJECT BASE_NODE_CLASS :
    import org.congocc.Grammar;
    import PARSER_PACKAGE.Token.TokenType;
    implements Node; 
{
    protected void setChildren(List<Node> children) {
        this.children = children;
    }

    private Grammar grammar;

    public Grammar getGrammar() {
        if (grammar == null) {
            if (parent != null) {
               grammar = parent.getGrammar();
            }
            if (grammar==null && !children.isEmpty()) {
               grammar = children.get(0).getGrammar();
            }
        }
        return grammar;
    }

    public void setGrammar(Grammar grammar) {
         this.grammar = grammar;
    }
    
    public String getSimpleName() {
        String name = getClass().getName();
        return name.substring(name.lastIndexOf(".") + 1); // strip the package name
    }

    public String toString() {
        StringBuilder buf = new StringBuilder();
        Token prevToken = null;
        for (Token t : getAllTokens(true)) {
            if (prevToken != null && prevToken.getEndOffset() != t.getBeginOffset()) {
                buf.append(" ");
            }
            buf.append(t);
            prevToken = t;
        }
        return buf.toString();
    }

    public String getInputSource() {
        return getTokenSource().getInputSource();
    }

    public String getLocation() {
        return getInputSource() + ":" + getBeginLine() + ":" + getBeginColumn();
    }

    public int getBeginLine() {
        TokenSource tokenSource = getTokenSource();
        return tokenSource == null ? 0 : tokenSource.getLineFromOffset(getBeginOffset());
    }

    public int getBeginColumn() {
        TokenSource tokenSource = getTokenSource();
        return tokenSource == null ? 0 : tokenSource.getCodePointColumnFromOffset(getBeginOffset());
    }
}

INJECT CompilationUnit : 
    import java.util.*;
{
    public String getPackageName() {
        PackageDeclaration jpd = getPackageDeclaration();
        return jpd == null ?  null : jpd.getPackageName().toString();
    }
    
    
    public PackageDeclaration getPackageDeclaration() {
        return firstChildOfType(PackageDeclaration.class);
    }
    
    public List<ImportDeclaration> getImportDeclarations() {
        return childrenOfType(ImportDeclaration.class);
    }
    
    public List<TypeDeclaration> getTypeDeclarations() {
        return childrenOfType(TypeDeclaration.class);
    }

    public void addImportDeclaration(ImportDeclaration decl) {
        Node firstTypeDeclaration = firstChildOfType(TypeDeclaration.class);
        if (firstTypeDeclaration == null) {
          firstTypeDeclaration = firstChildOfType(Delimiter.class); //lone semicolon, I suppose
        }
        addChild(indexOf(firstTypeDeclaration), decl);
    }
}

INJECT TypeDeclaration : 
    import java.util.*;
{
    default String getName() {
        return firstChildOfType(Identifier.class).toString();
    }
    
    default TypeParameters getTypeParameters() {
        return firstChildOfType(TypeParameters.class);
    }
    
    default ClassOrInterfaceBody getBody() {
        return firstChildOfType(ClassOrInterfaceBody.class);
    }
    
    default ExtendsList getExtendsList() {
        return firstChildOfType(ExtendsList.class);
    }
    
    default ImplementsList getImplementsList() {
        return firstChildOfType(ImplementsList.class);
    }
    
    default CompilationUnit getCompilationUnit() {
        return firstAncestorOfType(CompilationUnit.class);
    }
    
    default List<ImportDeclaration> getImportDeclarations() {
        CompilationUnit jcu = getCompilationUnit();
        return jcu==null ? new ArrayList<ImportDeclaration>() : jcu.getImportDeclarations();
    }
}

INJECT FormalParameter : 
{
    public String getName() {
        String result = null;
        Node last = getLastChild();

        if (last instanceof Identifier) {
            result = ((Identifier) last).getImage();
        }
        return result;
    }
}

INJECT FormalParameters : 
   import java.util.List;
{
    public List<FormalParameter> getParams() {
        return childrenOfType(FormalParameter.class);
    }
    
    public String toString() {
        StringBuilder buf = new StringBuilder();
        List<FormalParameter> params = getParams();
        boolean first = true;
        for (FormalParameter param : params) {
            if (!first) {
                buf.append(", ");
            }
            buf.append(param.toString());
            first = false;
        }
        return buf.toString();
    }
}

INJECT ImplementsList : 
   import java.util.*;
{    
    public List<ObjectType> getTypes() {
        return childrenOfType(ObjectType.class);
    }
    //REVISIT. fix token chaining?    
    public void addType(ObjectType type) {
        ListIterator<Node> iterator = iterator();
        if (!iterator.hasNext()) {
            iterator.add(Token.newToken(IMPLEMENTS, "implements", this.getTokenSource()));
            iterator.next();
            iterator.add(type);
        } else {
            while (iterator.hasNext()) {
                if (type.equals(iterator.next())) 
                    return;
            }
            iterator.add(Token.newToken(COMMA, ",", this.getTokenSource()));
            iterator.next();
            iterator.add(type);
        }
    }
}

INJECT CodeBlock :
  import java.util.List;
{
    public String toString() {
        StringBuilder buf = new StringBuilder();
        List<Token> tokens = getAllTokens(true);
        boolean outputOpeningBrace = false;
        for (int i=0; i<tokens.size() -1; i++) {
            Token t = tokens.get(i);
            buf.append(" ");
            if (i>0 && tokens.get(i-1).getEndOffset() != t.getBeginOffset()) {
                buf.append(" ");
            }
            if (outputOpeningBrace) {
                buf.append(t);
            } else if (t.getType() == TokenType.LBRACE) {
                outputOpeningBrace = true;
            }
            buf.append(" ");
        }
        return buf.toString();
    }
}

INJECT InvocationArguments : 
    import java.util.*;
{
    public List<Expression> getArgs() {
        return childrenOfType(Expression.class);
    }

    public String toString() {
        StringBuilder buf = new StringBuilder();
        List<Expression> args = getArgs();
        boolean first = true;
        for (Expression arg : args) {
            if (!first) {
                buf.append(", ");
            }
            buf.append(arg.toString());
            first = false;
        }
        return buf.toString();
    }
}

// In general, it is probably better to INCLUDE the (more stable) Java grammar
// that is in the bootstrap jarfile.
//INCLUDE JAVA
INCLUDE "../../examples/java/Java.ccc"

VariableDeclarator# : VariableDeclaratorId [ "=" VariableInitializer ] ;

INJECT TypeDeclaration : 
    import java.util.*;
    import PARSER_PACKAGE.Token.TokenType;
{
    default void addElements(List<ClassOrInterfaceBodyDeclaration> elements) {
        Set<String> keys = new HashSet<String>();
        for (ClassOrInterfaceBodyDeclaration decl : elements) {
            if (decl instanceof MethodDeclaration) {
                keys.add(((MethodDeclaration)decl).getFullSignature());
            }
        }
        //REVISIT. fix token chaining
        for (Iterator<Node> it = getBody().iterator(); it.hasNext();) {
            Node n = it.next();
            if (n instanceof MethodDeclaration) {
                String s = ((MethodDeclaration) n).getFullSignature();
                if (keys.contains(s)) {
                    it.remove();
                }
            }
        }
        getBody().prepend(elements);
    }
    
    default void addAnnotations(Set<Annotation> annotations) {
       Node parent = this.getParent();
       int index = parent.indexOf(this);
       //REVISIT. fix token chaining
       for (Annotation annotation : annotations) {
           parent.addChild(index, annotation);
       }
    } 
    
    default boolean isClass() {
        return firstChildOfType(TokenType.CLASS) != null;
    }
    
    default void addImplements(ObjectType type) {
        ImplementsList implementsList = getImplementsList();
        if (implementsList == null) {
           implementsList = new ImplementsList();
           ListIterator<Node> iterator = iterator();
           while (iterator.hasNext()) {
              Node node = iterator.next();
              if (node instanceof ClassOrInterfaceBody || node instanceof EnumBody)
                  break; 
           }
           iterator.previous();
           iterator.add(implementsList);
        }
        implementsList.addType(type);
    }

    default void addExtends(ObjectType type) {
        ExtendsList extendsList = getExtendsList();
        if (extendsList == null) {
            extendsList = new ExtendsList();
            ListIterator<Node> iterator = iterator();
            while (iterator.hasNext()) {
                Node node = iterator.next();
                if (node instanceof ImplementsList || node instanceof ClassOrInterfaceBody) {
                    break;
                }
            }
            iterator.previous();
            iterator.add(extendsList);
        }
        extendsList.addType(type, this instanceof InterfaceDeclaration);
    }
}

INJECT ExtendsList : 
     import java.util.*;
{
    //REVISIT. fix token chaining 
    
      public void addType(ObjectType type, boolean isInterface) {
        if (!isInterface) {
            clearChildren();
        }
        ListIterator<Node> iterator = iterator();
        if (!iterator.hasNext()) {
            iterator.add(Token.newToken(EXTENDS, "extends", this.getTokenSource()));
            iterator.next();
            iterator.add(type);
        } else {
            while (iterator.hasNext()) {
                if (type.equals(iterator.next())) 
                    return;
            }
            iterator.add(Token.newToken(COMMA, ",", this.getTokenSource()));
            iterator.next();
            iterator.add(type);
        }
    }
}

INJECT TypeParameters : 
    import java.util.*;
{
    // REVISIT. fix token chaining?
    public void add(TypeParameter param) {
        if (!getParameters().contains(param)) {
            ListIterator<Node> iterator = iterator();
            while(iterator.hasNext()) {
                iterator.next();
            }
            iterator.previous();
            iterator.add(Token.newToken(COMMA, ",", this.getTokenSource()));
            iterator.next();
            iterator.add(param);
        }
    }

    // REVISIT. fix token chaining 
    public void add(TypeParameters params) {
        for (TypeParameter param : params.getParameters()) {
            add(param);
        }
    }
}

INJECT ClassOrInterfaceBody : 
    import java.util.*;
{
    
    // REVISIT. fix token chaining?
    public void prepend(List<ClassOrInterfaceBodyDeclaration> elements) {
        ListIterator<Node> iterator = iterator();
        Node n = null;
        while (iterator.hasNext()) {
            n = iterator.next();
              if (n instanceof Token) {
              Token t = (Token) n;
               if (t.getType() == LBRACE) {
                   break;
               }
              }
        }
        for (ClassOrInterfaceBodyDeclaration elem : elements) {
            iterator.add(elem);
            iterator.next();
        }
    }
    
    // REVISIT. fix token chaining 
    public void removeDuplicateMethods() {
        Set<String> sigs = new HashSet<String>();
        ListIterator<Node> decls = iterator();
        while (decls.hasNext()) {
           Node n = decls.next();
           if (n instanceof MethodDeclaration) {
               MethodDeclaration decl = (MethodDeclaration) n;
               String sig = decl.getFullSignature();
               if (sig != null) {
                    if (sigs.contains(sig)) {
                        decls.remove();
                    } else {
                        sigs.add(sig);
                    }
               }
           }
        }
    }
}

INJECT FieldDeclaration : 
   import java.util.*;
{

  /**
   * @return the Identifier nodes that correspond to the 
   *          declaration of an instance variable. 
   */
  public List<Identifier> getVariableIds() {
     return descendants(Identifier.class, FieldDeclaration::isVariableDeclarator);
  }

  static boolean isVariableDeclarator(Identifier id) {
      Node parent = id.getParent();
      return parent instanceof VariableDeclaratorId || 
             parent instanceof VariableDeclarator ||
             parent instanceof FieldDeclaration;
  }
}


INJECT PARSER_CLASS : {

    private EnumSet<TokenType> CongoCCKeyWords = EnumSet.of(
       _FAIL, _ENSURE, _SCAN, _IGNORE_CASE, 
       _TOKEN, _UNPARSED, _SKIP, _MORE,
       _ATTEMPT, _RECOVER, _ON_ERROR,  
       _LEXICAL_STATE);

    private Token TOKEN_HOOK(Token t) {
        if (CongoCCKeyWords.contains(t.getType())) {
            if (isInProduction("CompilationUnit", "ClassOrInterfaceBody", "BlockStatement", "TreeBuildingAnnotation")) {
                Token id = Token.newToken(IDENTIFIER, t.getImage(), token_source);
                id.copyLocationInfo(t);
                return id;
            }
        }
        t.setGrammar(getGrammar());
        return t;
    }
}

INJECT MethodDeclaration : 
{
    public String getName() {
        return firstChildOfType(Identifier.class).toString();
    }
    
    public FormalParameters getFormalParameters() {
        return firstChildOfType(FormalParameters.class);
    }
    
    public String getFullSignature() {
        StringBuilder buf = new StringBuilder();
        buf.append(getName());
        for (Type type : getFormalParameters().childrenOfType(Type.class)) {
            buf.append("#");
            buf.append(type);
        }
        return buf.toString();
    }
}

INJECT VariableDeclarator : {
   public String getName() {
       return firstDescendantOfType(Identifier.class).getImage();
   }
}

INJECT ThrowsList : 
    import java.util.List;
    import java.util.ArrayList;
{
#if false    
    public List<Node> getTypes() {
        List<Node> result = new ArrayList<>();
        for (Node n : children()) {
           if ((n instanceof Name) || (n instanceof Identifier)) {
              result.add(n);
           }
        }
        return result; 
    }
#else

    public List<Node> getTypes() {
        return new ArrayList<Node>(childrenOfType(ObjectType.class));
    }    
#endif    
}

INJECT Identifier : 
{
    private String tokenHookName, resetTokenHookName, openHookName, closeHookName;

    public String getNormalizedText() {
        String image = getImage();
        if (image.equals("jjtThis") || image.equals("CURRENT_NODE")) { 
            return getGrammar().getCurrentNodeVariableName();
        }
        if (image.equals("PARSER_CLASS")) {
            return getGrammar().getParserClassName();
        }
        if (image.equals("LEXER_CLASS")) {
            return getGrammar().getLexerClassName();
        }
        if (image.equals("BASE_NODE_CLASS")) {
            return getGrammar().getBaseNodeClassName();
        }
        if (image.equals("NODE_PACKAGE")) {
            return getGrammar().getNodePackage();
        }
        if (image.equals("PARSER_PACKAGE")) {
            return getGrammar().getParserPackage();
        }
        if (image.equals("TOKEN_HOOK")) {
            if (tokenHookName ==null) {
                String prefix = getGrammar().generateIdentifierPrefix("tokenHook");
                tokenHookName = getGrammar().generateUniqueIdentifier(prefix, this);
            }
            return tokenHookName;
        }
        if (image.equals("RESET_TOKEN_HOOK")) {
            if (resetTokenHookName == null) {
                String prefix = getGrammar().generateIdentifierPrefix("resetTokenHook");
                resetTokenHookName = getGrammar().generateUniqueIdentifier(prefix, this);
            }
            return resetTokenHookName;
        }
        if (image.equals("OPEN_NODE_HOOK")) {
            if (openHookName == null) {
                String prefix = getGrammar().generateIdentifierPrefix("openNodeHook");
                openHookName = getGrammar().generateUniqueIdentifier(prefix, this);
            }
            return openHookName;
        }
        if (image.equals("CLOSE_NODE_HOOK")) {
            if (closeHookName == null) {
                String prefix = getGrammar().generateIdentifierPrefix("closeNodeHook");
                closeHookName = getGrammar().generateUniqueIdentifier(prefix, this);
            }
            return closeHookName;
        }
        return image;
   }
}

INJECT interface Node :
   import org.congocc.Grammar;
{
    Grammar getGrammar();
    void setGrammar(Grammar grammar);
    default Node getNamedChild(String name) { return null; }
    default void setNamedChild(String name, Node node) {}
    default  List<Node> getNamedChildList(String name) { return null; }
    default void addToNamedChildList(String name, Node node) {}
}


INJECT Token :
    import org.congocc.Grammar;
{
    private Grammar grammar;

    public Grammar getGrammar() {
        if (grammar == null) {
           if (parent != null) {
              grammar = parent.getGrammar();
           }
        }
        return grammar;
    }

    public void setGrammar(Grammar grammar) {
         this.grammar = grammar;
    }
    
    public String getNodeName() {
        return getType().toString();
    }
    
    public String getLeadingComments() {
        Token specialToken = getPreviousToken() == null || !getPreviousToken().isUnparsed() ? null : getPreviousToken();
        if (specialToken == null)
            return "";
        StringBuilder buf = new StringBuilder();
        Token tok = specialToken;
        while (tok.getPreviousToken() != null && tok.getPreviousToken().isUnparsed()) {
            tok = tok.getPreviousToken();
        }
        while (tok != this && tok != null) {
            buf.append(tok);
            tok = tok.getNext();
        }
        return buf.toString();
    }
    
    public String getNormalizedText() {
        return getImage();
    }
}

#Root throws IOException #GrammarFile :
{
    TokenProduction tp;
}
   [
      Options
   ]!
   (
      tp=TokenProduction  {grammar.addTokenProduction(tp);}
      |
      CodeInjection2 
      |
      CodeInjection
      |
      GrammarInclusion =>||
      |
      BNFProduction
  )+!
  <EOF>
  {
        return CURRENT_NODE;
  }
;

INJECT ReturnType :
    import java.util.List;
{
    public boolean getAsBoolean() {
        List<Token> lt = getRealTokens();
        return lt.size() != 1 || lt.get(0).getType() != VOID;
    }
}

INJECT PARSER_CLASS : {
    private boolean enterIncludes = true, isAlias = false;
    public void setEnterIncludes(boolean enterIncludes) {this.enterIncludes = enterIncludes;}
}

GrammarInclusion throws IOException :
{
   List<String> locations = new ArrayList<>();
   Token includeToken;
}
   ACTIVATE_TOKENS _INCLUDE (<_INCLUDE>)
   {includeToken = lastConsumedToken;}
   (
       (
           <STRING_LITERAL> {locations.add(((StringLiteral)lastConsumedToken).getString());}
           |
           <IDENTIFIER> {locations.add(lastConsumedToken.getImage());}
       )
       (
         "!" 
         (<STRING_LITERAL>|<IDENTIFIER>)
         {
           if (lastConsumedToken instanceof StringLiteral) {
              locations.add(((StringLiteral) lastConsumedToken).getString());
           } else {
               locations.add(lastConsumedToken.getImage());
           }
         }
       )*
       |
       "(" <STRING_LITERAL> {locations.add(((StringLiteral)lastConsumedToken).getString());} ")" 
   )
   [";"]
   {
      if (enterIncludes) {
          Node included = grammar.include(locations, includeToken);
          if (included!=null) {
              CURRENT_NODE.addChild(included);
          } else {
              grammar.addWarning(CURRENT_NODE, "File is already included.");
          }
      }
   }
;

CodeInjection :
{
    boolean isInterface = false;
    Annotation annotation = null;
    boolean foundOptionalInitialBrace = false;
    boolean usingParentheses = false;
    ImportDeclaration id;
    ObjectType ot;
    Annotation ann;
    ClassOrInterfaceBody coib;
}   
        ACTIVATE_TOKENS _INJECT (<_INJECT>) ["(" {usingParentheses = true;}]
        [
            "class"
            |
            "interface" {isInterface = true;}
        ]
        <IDENTIFIER> {CURRENT_NODE.name = lastConsumedToken.toString();} 
        [
            SCAN {usingParentheses} => ")"
        ]
        ":"
        =>|+1
        [
          SCAN "{" ("}" | "import" | "extends" | "implements" | (Annotation)* "}") => "{"
          {foundOptionalInitialBrace=true;}
        ]
        (
            id=ImportDeclaration {CURRENT_NODE.importDeclarations.add(id);}
        )*
        (
            ann=Annotation {CURRENT_NODE.annotations.add(ann);}
        )*
        [
             "extends" 
             ot=ObjectType {CURRENT_NODE.addExtendsType(ot);}
             (SCAN 1 {isInterface} => "," ot=ObjectType {CURRENT_NODE.addExtendsType(ot);})*
             [";"]
        ]
        [
             SCAN 1 {!isInterface} =>
             "implements" ot=ObjectType {CURRENT_NODE.addImplementsType(ot);}
             ("," ot=ObjectType {CURRENT_NODE.addImplementsType(ot);})*
             [";"]
        ]
        [
           SCAN 0 {foundOptionalInitialBrace} => "}"
        ]
        [coib=ClassOrInterfaceBody {CURRENT_NODE.body = coib;}]
        {
                if (enterIncludes) {
                    grammar.addCodeInjection(CURRENT_NODE);
                }
        }
;

INJECT CodeInjection : 
   import java.util.List;
   import java.util.ArrayList;
{
   public String name;
   public List<ImportDeclaration> importDeclarations = new ArrayList<ImportDeclaration>();
   public List<Annotation> annotations = new ArrayList<>();
   public List<ObjectType> extendsList = new ArrayList<>();
   public List<ObjectType> implementsList = new ArrayList<>();
   public ClassOrInterfaceBody body; 
   public boolean isInterface;   

   public void addExtendsType(ObjectType type) {extendsList.add(type);}
   public void addImplementsType(ObjectType type) {implementsList.add(type);}
}

CodeInjection2 :
{
        CompilationUnit jcu;
}
        ACTIVATE_TOKENS _INJECT (<_INJECT>)
        ":" =>|| "{"
        jcu=CompilationUnit
       "}"
        {
                if (enterIncludes) {
                    grammar.addCodeInjection(jcu);
                }
        }
;

Options# :
    {HashMap<String, Object> settings = new HashMap<>();} 
    Setting(settings) =>||
    (Setting(settings))*
    {grammar.setSettings(settings);}
;

Setting(Map<String,Object> settings) #Setting :
{
      String key;
      Token name;
      Object value = Boolean.TRUE;
}
  ( 
     name = <IDENTIFIER> 
     | 
     name = <_IGNORE_CASE>
     |
     name = <_DEACTIVATE_TOKENS>
  )
  =>|+1
  {
      key = name.getImage().toUpperCase();
  }
  [
     "="
     (
        "true" {value=true;}
        |
        "false" {value=false;}
        |
        <INTEGER_LITERAL> {value = ((IntegerLiteral) lastConsumedToken).getValue();}
        |
        <STRING_LITERAL> {value = ((StringLiteral) lastConsumedToken).getString();}
        |
        SCAN <IDENTIFIER> "."
        =>Name {value = peekNode().toString();}
        |
        <IDENTIFIER> {value = lastConsumedToken.getImage();}
        [ <HASH> <IDENTIFIER> { value += "#" + lastConsumedToken.getImage();} ]
        ("," {value+=",";}
            <IDENTIFIER> {value+=lastConsumedToken.getImage();}
            [ <HASH> <IDENTIFIER> { value += "#" + lastConsumedToken.getImage();} ]
        )* 
     )
  ]
  ";"
  {
      settings.put(key, value);
  }
;

BNFProduction #org.congocc.core.BNFProduction :
{
    TreeBuildingAnnotation tba = null;
    Token firstToken=getToken(1), id;
    Expansion exp;
}
    [
        "public" | "private" | "protected"
    ]
    [
       SCAN ReturnType <IDENTIFIER> => ReturnType
       |
       "#" {CURRENT_NODE.setImplicitReturnType(true);}
    ]
    id=<IDENTIFIER> {CURRENT_NODE.setName(id.getImage());}
    [FormalParameters]
    [
      ThrowsList
    ]
    [
        tba=TreeNodeDescriptor 
        {
            String nodeName = tba.getNodeName();
            if (nodeName == null) nodeName = CURRENT_NODE.getNodeName();
            grammar.addNodeType(CURRENT_NODE.getName(), nodeName);
        }
    ]
    [
        "RECOVER_TO" ExpansionChoice
        {CURRENT_NODE.setRecoveryExpansion((Expansion)peekNode());} 
    ]
    ":"
    [
        SCAN 2 => <IDENTIFIER> 
        {CURRENT_NODE.setLexicalState(lastConsumedToken.getImage());}
        ":"
    ]
    [
        Block 
        {CodeBlock block = (CodeBlock) peekNode();}
        ["#" {block.setAppliesInLookahead(true);}]
        ASSERT ~(";") =>||
    ]
    ExpansionChoice 
    {CURRENT_NODE.setExpansion((Expansion) peekNode());} 
    ";"
    {
        CURRENT_NODE.adjustFirstToken(firstToken);
        if (tba == null && !grammar.getNodeDefaultVoid()) {
           grammar.addNodeType(CURRENT_NODE.getName(),CURRENT_NODE.getName());
        }
     }
;

TreeNodeDescriptor #TreeBuildingAnnotation :
  "#" 
  (
      SCAN 0 \BNFProduction => 
      (Name|"abstract"|"interface"|"void"|{})
      |
      Name
  )
  [
       "("
          [
            (">" | ">=" | "<" | "<=" | "+" | "-")
            {CURRENT_NODE.setInitialShorthand(lastConsumedToken.getImage());}  
          ]
          Expression {CURRENT_NODE.setCondition((Expression) peekNode());}
       ")"
  ]
;

INJECT TreeBuildingAnnotation :
{
    @Property String initialShorthand;
    @Property Expression condition;
    /**
     * Just returns whatever comes after the hash ("#") including "void", etc.
     */
    public String getNodeName() {
        Token hash = (Token) firstChildOfType(HASH);
        if (hash == null) return null;
        Node nextNode = hash.nextSibling();
        if (nextNode instanceof Name) {
            return nextNode.toString();
        }
        Token nextToken = hash.getNext();
        TokenType nextType = nextToken.getType();
        if (nextType != ABSTRACT 
            && nextType != INTERFACE 
            && nextType != VOID) return null;
        return nextToken.getImage();
    }

    public boolean isNeverInstantiated() {
        return isVoid() || isAbstract() || isInterface();
    }
    
    public boolean getGtNode() {
         return initialShorthand !=null;
    }

    public boolean isAbstract() {
        return "abstract".equals(getNodeName());
    }

    public boolean isInterface() {
        return "interface".equals(getNodeName());
    }
    
    public boolean isVoid() {
        return "void".equals(getNodeName());
    }

    public boolean isFullyQualified() {
        String nodeName = getNodeName();
        return nodeName != null && nodeName.indexOf('.') >0;
    }
}


TokenProduction :
{
    Token t = null;
    String tokenClassName = null;
    String firstSpecifiedLexicalState = null;
    boolean multipleStatesSpecified = false;
    boolean ignoreCase = false;
}
  [
    "<" "*" =>|| ">" {multipleStatesSpecified = true;} 
    |
    "<" <IDENTIFIER>
      {
          firstSpecifiedLexicalState = lastConsumedToken.getImage();
          grammar.addLexicalState(firstSpecifiedLexicalState);
      }
      ("," <IDENTIFIER> {multipleStatesSpecified = true; grammar.addLexicalState(lastConsumedToken.getImage());})*
     ">" 
  ]
  (<_TOKEN> | <_UNPARSED> | <_SKIP> | <_MORE>)
  [
    "[" "IGNORE_CASE" {ignoreCase = true;} "]"
  ]
  ["#" <IDENTIFIER> {
    tokenClassName=lastConsumedToken.getImage();
    CURRENT_NODE.setTokenClassName(tokenClassName);
    }
  ] 
  ":"
   RegexpSpec(tokenClassName)
   ( "|" RegexpSpec(tokenClassName) )*
   (
      ";"
   )
   {
      if (!multipleStatesSpecified) {
          if (firstSpecifiedLexicalState == null) {
              firstSpecifiedLexicalState = grammar.getDefaultLexicalState();
          }
          CURRENT_NODE.setImplicitLexicalState(firstSpecifiedLexicalState);
      }
      CURRENT_NODE.setIgnoreCase(ignoreCase || grammar.isIgnoreCase());
   }
;

INJECT TokenProduction :
    import java.util.*;
{
    @Property private boolean explicit=true, ignoreCase;
    @Property String tokenClassName;

    private String implicitLexicalState;
    
    public void setImplicitLexicalState(String implicitLexicalState) {
        this.implicitLexicalState = implicitLexicalState;
    }

    public List<RegexpSpec> getRegexpSpecs() {
        return childrenOfType(RegexpSpec.class);
    }

    /**
     * The states in which this regular expression production exists.
     */
    public String[] getLexicalStateNames() {
    
        if (implicitLexicalState != null) {
            return new String[] {implicitLexicalState};
        }        
        if (isInAllLexStates()) {
             return getGrammar().getLexicalStates();
        }
        Set<String> states = new LinkedHashSet<String>();
        for (Token t : childrenOfType(Token.class)) {
            if (t.getType() == HASH) break;
            if (t.getType() == IDENTIFIER) {
                states.add(t.getImage());
            }
        }
        if (states.isEmpty()) {
           return new String[] {getGrammar().getDefaultLexicalState()};
        }
        String[] lexStates = new String[states.size()];
        int i=0;
        for (String s : states) {
           lexStates[i++] = s;
        } 
        return lexStates;
    }
    
    private boolean isInAllLexStates() {
       for (Node n : children()) {
          if (n instanceof Token) {
          Token t = (Token) n;
              if (t.getType() == STAR) {
                  return true;
              }
          }
       }
       return false;
    }

    public String getKind() {
       for (Token t : childrenOfType(Token.class)) {
           switch (t.getType()) {
              case _MORE : return "MORE";
              case _UNPARSED : return "UNPARSED";
              case _SKIP : return "SKIP";
              case _TOKEN : return "TOKEN";
              default: 
           }
      }
      return "TOKEN";
    }
}

RegexpSpec(String tokenClassName) #RegexpSpec :
{
    RegularExpression regexp;
    boolean isPrivate = false;
    String image = "";
}
(
  RegexpStringLiteral {regexp = (RegularExpression) peekNode();}
  |
  <LT>
  [
    ["#" {isPrivate = true;}]
    <IDENTIFIER> {image = lastConsumedToken.getImage();}
    ":"
  ]
  RegexpChoice {regexp = (RegularExpression) peekNode();} 
  <GT>
  {
      if (regexp instanceof RegexpRef) {
        RegexpSequence seq = new RegexpSequence();
        seq.addChild(regexp);
        pokeNode(seq);
        regexp = seq;
      } 
      regexp.setLabel(image);
      regexp.setGeneratedClassName(image);
      regexp.setPrivate(isPrivate); 
  }
 )
 {
      if (tokenClassName != null) {
          regexp.setGeneratedClassName(tokenClassName);
      }
 }
 [
     "#"<IDENTIFIER>
     {
        regexp.setGeneratedSuperClassName(tokenClassName);
        regexp.setGeneratedClassName(lastConsumedToken.getImage());
     }
  ]
  [
      SCAN 1 {!regexp.isPrivate()} =>
      Block
  ]
  [ 
      SCAN 1 {!regexp.isPrivate()} =>
      ":" <IDENTIFIER> {CURRENT_NODE.setNextLexicalState(lastConsumedToken.getImage());}
  ]
;

INJECT RegexpSpec : 
   import org.congocc.core.RegularExpression;
{

    @Property String nextLexicalState;

    public RegularExpression getRegexp() {
         return firstChildOfType(RegularExpression.class);
    }

    public CodeBlock getCodeSnippet() {
        return firstChildOfType(CodeBlock.class);
    }
}

ExpansionChoice #org.congocc.core.ExpansionChoice(>1) : 
  ExpansionSequence ( "|" ExpansionSequence)*
;

ExpansionWithParentheses :
{
    Token lparen = null;
    LexicalStateSwitch lss=null;
}
   [lss=LexicalStateSwitch | TokenActivation]
   lparen ="(" =>|| ExpansionChoice {Expansion nested = (Expansion) peekNode();} ")"
   [
       "*" {CURRENT_NODE = new ZeroOrMore();}
       |
       "?" {CURRENT_NODE = new ZeroOrOne();}
       |
       "+" {CURRENT_NODE = new OneOrMore();}
   ]
   [
       SCAN ~\...\Lookahead => 
       "!" 
       {
           if (CURRENT_NODE instanceof ZeroOrOne) {
               nested.setTolerantParsing(true);
           } else {
               CURRENT_NODE.setTolerantParsing(true);
           }
       }
   ]
   [UpToHere(CURRENT_NODE)]
   {
       Node startNode = lss != null ? lss : lparen;
       CURRENT_NODE.copyLocationInfo(startNode, lastConsumedToken);
   }
;


INJECT ExpansionWithParentheses : 
   import org.congocc.core.TokenSet;
   import org.congocc.core.Expansion;
   extends Expansion
{
    public int getMaximumSize() {return getNestedExpansion().getMaximumSize();}
    public int getMinimumSize() {return getNestedExpansion().getMinimumSize();}
    public boolean isPossiblyEmpty() {return getNestedExpansion().isPossiblyEmpty();}
    public boolean isAlwaysSuccessful() {return getNestedExpansion().isAlwaysSuccessful();}
    public TokenSet getFirstSet() {return getNestedExpansion().getFirstSet();}
    public TokenSet getFinalSet() {return getNestedExpansion().getFinalSet();}

    public Expansion getNestedExpansion() {
        return firstChildOfType(Expansion.class);
    }

    public String getSpecifiedLexicalState() {
        LexicalStateSwitch lss = firstChildOfType(LexicalStateSwitch.class);
        return lss == null ? super.getSpecifiedLexicalState() : lss.getLexicalStateName();
    }

    public boolean potentiallyStartsWith(String productionName, java.util.Set<String> alreadyVisited) {
        return getNestedExpansion().potentiallyStartsWith(productionName, alreadyVisited);
    }

    public boolean startsWithLexicalChange() {
        return firstChildOfType(LexicalStateSwitch.class) != null || firstChildOfType(TokenActivation.class) != null
              || getNestedExpansion().startsWithLexicalChange();
    }

    public boolean startsWithGlobalCodeAction() {
        return getNestedExpansion().startsWithGlobalCodeAction();
    }

    public boolean isSingleToken() {
         return super.isSingleToken() && getNestedExpansion().isSingleToken();
    }
}

ExpansionSequence #org.congocc.core.ExpansionSequence :
{
   Expansion sub;
   Lookahead la = null;
}
  [ 
    SCAN ~\...\Lookahead 
    =>
    la=Lookahead  =>||
    {
       la.setExpansion(CURRENT_NODE);
       CURRENT_NODE.setLookahead(la);
     }
  ]
  (
     sub=ExpansionUnit =>||
     {
         pokeNode(sub);
     }
  )+!
;

INJECT Assertion :
   import org.congocc.core.Expansion;
   extends org.congocc.core.EmptyExpansion 
{
    @Property Expression assertionExpression, messageExpression;
    @Property Expansion expansion;
    @Property boolean expansionNegated, semanticLookaheadNested;

    public boolean isAlwaysSuccessful() {return false;}

    public boolean startsWithGlobalCodeAction() {
        return expansion != null || semanticLookaheadNested;
    }
}


Assertion :
   "ASSERT"
   (
    "{" 
       Expression 
       {CURRENT_NODE.setAssertionExpression((Expression) peekNode());}
    "}"
    ["#" {CURRENT_NODE.setSemanticLookaheadNested(true);}]
    |
    ["~" {CURRENT_NODE.setExpansionNegated(true);}] 
    "(" 
    ExpansionChoice {CURRENT_NODE.setExpansion((Expansion) peekNode());}
    ")"
   )
   [
       ":" Expression {CURRENT_NODE.setMessageExpression((Expression)peekNode());}
       [":"]
   ]
   [UpToHere(CURRENT_NODE)]
;

org.congocc.core.Lookahead Lookahead #org.congocc.core.Lookahead : 
{
   Token amountToken=null;
   boolean hasSemanticLookahead = false, getHasExplicitNumericalLookahead=false;
   Expansion expansion = null;
   Expression exp=null;
   Name name = null;
   Node lb = null;
}
[name=Name "=" =>|| {CURRENT_NODE.setLHS(name);}]
<_SCAN>
[
    <INTEGER_LITERAL> {getHasExplicitNumericalLookahead = true;}
]
[
    "{" 
    exp=Expression {hasSemanticLookahead = true; CURRENT_NODE.setSemanticLookahead(exp);}
    "}"
    ["#" {CURRENT_NODE.setSemanticLookaheadNested(true);}]
]
[LookBehind =>|| {lb = peekNode();}]
[
    SCAN {!getHasExplicitNumericalLookahead} => 
    ["~" {CURRENT_NODE.setNegated(true);}] 
    ExpansionChoice {expansion = (Expansion) peekNode();}
    <RIGHT_ARROW> =>||
    {
       CURRENT_NODE.setNestedExpansion(expansion);
    }
]
(
    SCAN {expansion == null} => <RIGHT_ARROW>
    |
    SCAN {expansion != null || (exp ==null && lb == null)} => {}
)
{return CURRENT_NODE;}
;

LookBehind : 
   [<TILDE> {CURRENT_NODE.setNegated(true);}] 
   (LookBehindForward | LookBehindBackward)
;

LookBehindForward #void :
   (
       <SLASH>
       (
         ([<TILDE>]<IDENTIFIER>)
         |
         (<DOT>|<VAR_ARGS>)
       )
   )+
   [<BACKSLASH>]
;

LookBehindBackward #void :
   (
       <BACKSLASH>
       (
          ([<TILDE>]<IDENTIFIER>)
          |
          (<DOT>|<VAR_ARGS>)
       )
   )+
   [<SLASH>]
;

INJECT LookBehind :
import java.util.*;
{
    @Property boolean negated;

    public boolean isBackward() {
        return getChild(0) instanceof Backslash || getChild(1) instanceof Backslash;
    }

    public boolean getHasFinalEllipsis() {
        Token t = (Token) getChild(getChildCount() -1);
        return t.getImage().equals("...");
    }

    public List<String> getPath() {
        ArrayList<String> result = new ArrayList<>();
        boolean negated = false;
        for (Token t : childrenOfType(Token.class)) {
            String img = t.getImage();
            if (img.charAt(0) == '\\' || img.charAt(0)=='/') {
                negated = false;
                continue;
            } 
            if (img.equals("~")) {
                negated = true;
                continue;
            }
            if (negated) {
                result.add("~" + img);
            } else {
               result.add(img);
            }
            negated = false;
        }
        if (result.get(0).equals("~")) {
            result.remove(0);
        }
        return result;
    }

    public boolean getHasEndingSlash() {
        Token lastToken = (Token) getChild(getChildCount()-1);
        String img = lastToken.getImage();
        return img.equals("\\") || img.equals("/");
    }

    private String routineName;
    
    public String getRoutineName() {
        if (routineName == null) {
            String prefix = getGrammar().generateIdentifierPrefix("backscan");
            routineName = getGrammar().generateUniqueIdentifier(prefix, this);
        }
        return routineName;
    }
}


ChildNameInfo(Expansion expansion) : //#void :
{
    String name;
    boolean multiple = false;
}
  // TODO these delimiters are provisional - agreement needed on final form
  "/"
  (
    <IDENTIFIER> { name = ((Token) peekNode()).getImage(); }
    |
    ( "["
      <IDENTIFIER> { name = ((Token) peekNode()).getImage(); multiple = true; }
    "]" )
  )
  "/"
  {
    expansion.setChildName(name);
    expansion.setMultipleChildren(multiple);
  }
;

Expansion ExpansionUnit :
{
    //Name lhs=null;
    Expansion result=null;
    TreeBuildingAnnotation tba = null;
}
 (
  result=UncacheTokens
  |
  result = Failure
  |
  result=Block 
  [
    "#" 
    {
        ((CodeBlock)result).setAppliesInLookahead(true);
         //result.addChild(lastConsumedToken);
    }
  ]
  |
  result = UnparsedCodeBlock
  |
  SCAN 1 ~\...\Lookahead =>
  result=AttemptBlock
  |
  SCAN 1 ~\...\Lookahead =>
  result=TryBlock
  |
  result = Assertion
  |
  result = ExpansionWithParentheses 
  |
  result = ZeroOrOne 
  |
  result=Terminal
  |
  result=NonTerminal 
  |
  FAIL
 )
 [
     SCAN 1 ~\...\Lookahead => 
    tba=TreeNodeDescriptor
 ]
 {
        result.setTreeNodeBehavior(tba);
        return result;
 }
;

#NonTerminal #org.congocc.core.NonTerminal :
  [
    Name {CURRENT_NODE.setLHS((Name)peekNode());} "=" 
    =>||
  ]
  <IDENTIFIER>
  =>||
  [
    SCAN "(" ExpansionSequence "|" => {}
    |
    SCAN "(" ExpansionChoice ")" ("*"|"+"|"?") => {}
    |
    InvocationArguments =>||
  ]
  [
     SCAN ~\...\Lookahead =>
     "!"
     {CURRENT_NODE.setTolerantParsing(true);}
  ]
  [ChildNameInfo(CURRENT_NODE)] 
  [UpToHere(CURRENT_NODE)]
  {return CURRENT_NODE;}
;

RegularExpression Terminal #void :
{
    Name lhs=null;
    RegularExpression result=null;
}
  SCAN [Name "="] (<STRING_LITERAL>|"<")
  =>
  [
    SCAN ~\...\Lookahead Name "=" =>
    lhs = Name
    "="
  ]
  ACTIVATE_TOKENS _EOF(RegexpStringLiteral | RegexpRef | EndOfFile ) 
  {
      result = (RegularExpression) peekNode();
      result.setLHS(lhs);
      if (!(result instanceof EndOfFile)) {
            grammar.addInplaceRegexp(result);
      }
  }
  [
      SCAN {isInProduction("BNFProduction") && !isInProduction("Lookahead")}
      =>
      {
          RegularExpression regexp = (RegularExpression) peekNode();
          regexp.setTolerantParsing(true);
      }
      "!" {regexp.addChild(popNode());}
  ]
  [
    ChildNameInfo(result)
    {result.addChild(popNode());}
  ] 
  [
    UpToHere(result)
    {result.addChild(popNode());}
  ]
  {
    return result;
  }
;  

UpToHere(Expansion exp) #void :
   <UP_TO_HERE>
   {
       String img = lastConsumedToken.getImage();
       exp.setScanLimit(true);
       int lastChar = img.codePointBefore(img.length());
       if (Character.isDigit(lastChar)) {
           exp.setScanLimitPlus(lastChar - '0');
       }
   }
;

//The following two productions are not actually used. These constructs are now 
// handled by ExpansionWithParentheses so the following two productions
// are not actually used. They have to be there so that the ZeroOrMore and
// OneOrMore types get defined. REVISIT. Need a way of defining Node subtypes
// without creating a dummy grammar rule for them.
ZeroOrMore : "(" ExpansionChoice ")" "*";
OneOrMore : "(" ExpansionChoice ")" "+"; 

//This production just matches the square bracket syntax. 
// The (...)? syntax is handled by ExpansionWithParentheses
ZeroOrOne : 
    [LexicalStateSwitch | TokenActivation]
    "[" =>|| ExpansionChoice {Expansion exp = (Expansion) peekNode();} "]"
     ["!" {exp.setTolerantParsing(true);}]
     [UpToHere(CURRENT_NODE)]
;

INJECT ZeroOrOne : 
     import org.congocc.core.Expansion;
     import org.congocc.core.TokenSet;
     extends ExpansionWithParentheses 
{
    public boolean isAlwaysSuccessful() {return true;}
    public boolean isPossiblyEmpty() {return true;}
    public int getMinimumSize() {return 0;}
}


INJECT ZeroOrMore : 
     import org.congocc.core.Expansion;
     import org.congocc.core.TokenSet;
     extends ExpansionWithParentheses 
{
    public boolean isPossiblyEmpty() {return true;}
    public boolean isAlwaysSuccessful() {return true;}
    public int getMinimumSize() {return 0;}
    public int getMaximumSize() {return Integer.MAX_VALUE;}
}


INJECT OneOrMore : 
     import org.congocc.core.Expansion;
     import org.congocc.core.TokenSet;
     extends ExpansionWithParentheses 
{
     public int getMaximumSize() {return Integer.MAX_VALUE;}
     public boolean isPossiblyEmpty() {return false;}
}


AttemptBlock : 
 "ATTEMPT" ExpansionChoice "RECOVER"  (ExpansionWithParentheses | Block)
;

INJECT AttemptBlock : 
   import java.util.List;
   import org.congocc.core.Expansion;
   import org.congocc.core.TokenSet;
   extends Expansion;
{
   public Expansion getNestedExpansion() {
       return firstChildOfType(Expansion.class);
   }
   
   public Expansion getRecoveryExpansion() {
       return (Expansion) getChild(3);
    }
   
    public boolean isPossiblyEmpty() {
        return getNestedExpansion().isPossiblyEmpty();
    }
    
    public boolean isAlwaysSuccessful() {
        return getNestedExpansion().isAlwaysSuccessful();
    }
    
    //REVISIT: Should this take RECOVER into account? I don't think so,
    // but I still have to think about it a bit more.
    public TokenSet getFirstSet() {
        if (firstSet == null) {
           firstSet=getNestedExpansion().getFirstSet();
        }
        return firstSet;
    }
   
   
    //REVISIT: Should this take RECOVER into account? 
    public TokenSet getFinalSet() {
        return getNestedExpansion().getFinalSet();
    }
     
     public int getMinimumSize() {
         return getNestedExpansion().getMinimumSize();
     }

     public int getMaximumSize() {
         return getNestedExpansion().getMaximumSize();
     }

     public boolean startsWithLexicalChange() {
        return getNestedExpansion().startsWithLexicalChange();
     }

     public boolean startsWithGlobalCodeAction() {
        return getNestedExpansion().startsWithGlobalCodeAction();
     }
}

UncacheTokens# : "UNCACHE_TOKENS" ;   

INJECT UncacheTokens : extends org.congocc.core.EmptyExpansion;

Failure# : 
   {
       Expression exp = null;
   }
   "FAIL"
   [
      [":"]
      exp=Expression 
      |
      Block
   ]
   {
       CURRENT_NODE.setExp(exp);
   }
;

INJECT Failure :
   extends org.congocc.core.EmptyExpansion
{
    @Property Expression exp;
    public CodeBlock getCode() {
        return firstChildOfType(CodeBlock.class);
    }

    public boolean isAlwaysSuccessful() {return false;}

    public boolean startsWithGlobalCodeAction() {return true;}    
}

LexicalStateSwitch : "LEXICAL_STATE" <IDENTIFIER> ;

INJECT LexicalStateSwitch : {
   public String getLexicalStateName() {
       return firstChildOfType(Identifier.class).getImage();
   }
}

TokenActivation : 
   ("ACTIVE_TOKENS" | "ACTIVATE_TOKENS" | "DEACTIVATE_TOKENS" {CURRENT_NODE.setDeactivate(true);})
   ["+"|"-"] <IDENTIFIER>
   ([","] ["+"|"-"] <IDENTIFIER>)*
;

INJECT TokenActivation : 
   import java.util.List;
   import java.util.ArrayList;
{
    @Property boolean deactivate;
    public List<String> getTokenNames() {
        List<String> result = new ArrayList<>();
        for (Identifier id : childrenOfType(Identifier.class)) {
            result.add(id.getImage());
        }
        return result;
    }

    public List<String> getDeactivatedTokens() {
        List<String> result = new ArrayList<>();
        for (Identifier id : childrenOfType(Identifier.class)) {
            if (id.getPrevious().getType() == MINUS) {
                result.add(id.getImage());
            }
            else if (isDeactivate() && id.getPrevious().getType() != PLUS) {
                result.add(id.getImage());
            }
        }
        return result;
    }

    public List<String> getActivatedTokens() {
        List<String> result = new ArrayList<>();
        for (Identifier id : childrenOfType(Identifier.class)) {
            if (id.getPrevious().getType() == PLUS) {
                result.add(id.getImage());
            }
            else if (!isDeactivate() && id.getPrevious().getType() != MINUS) {
                result.add(id.getImage());
            }
        }
        return result;
    }
}


TryBlock : 
    "try" "{" ExpansionChoice "}"
    (
        CatchBlock
    )*
    [
        FinallyBlock
    ]
;

INJECT TryBlock  : 
    import java.util.List;
    import org.congocc.core.TokenSet;
    import org.congocc.core.Expansion;
    extends Expansion;
{
    public Expansion getNestedExpansion() {
        return firstChildOfType(Expansion.class);
    }
    
    public List<CatchBlock> getCatchBlocks() {
        return childrenOfType(CatchBlock.class);
    }

    public FinallyBlock getFinallyBlock() {
        return firstChildOfType(FinallyBlock.class);
    }
    
    public boolean isPossiblyEmpty() {
        return getNestedExpansion().isPossiblyEmpty();
    }
    
    public boolean isAlwaysSuccessful() {
        return getNestedExpansion().isAlwaysSuccessful();
    }
    
    public TokenSet getFirstSet() {
        return getNestedExpansion().getFirstSet();
    }
    
    public TokenSet getFinalSet() {
        return getNestedExpansion().getFinalSet();
    }
     
    public int getMinimumSize() {
        return getNestedExpansion().getMinimumSize();
    }

    public int getMaximumSize() {
        return getNestedExpansion().getMaximumSize();
    }
    
    public boolean startsWithLexicalChange() {
        return getNestedExpansion().startsWithLexicalChange();
    }

    public boolean startsWithGlobalCodeAction() {
        return getNestedExpansion().startsWithGlobalCodeAction();
    }
}


INJECT CodeBlock :
   extends org.congocc.core.EmptyExpansion;
{
    @Property boolean appliesInLookahead;

    public CodeBlock getJavaCode() {
        return this;
    }
    
    public boolean isPossiblyEmpty() {
       return true;
    }

    public boolean startsWithGlobalCodeAction() {
        return isAppliesInLookahead();
    }
}

RegexpStringLiteral# :
   (<STRING_LITERAL>|<CHARACTER_LITERAL>|<SINGLE_QUOTE_STRING>)
   {
      String image = StringLiteral.removeEscapesAndQuotes(lastConsumedToken.getImage());
      CURRENT_NODE.setImage(image);
   }
;

INJECT RegexpStringLiteral : 
   import org.congocc.core.*;
   extends RegularExpression;
{
  @Property String image;

  public String toString() {
    return super.toString() + " - " + getImage();
  }
  
  //REVISIT What about different lexical states? As well as ignoreCase... 
  public boolean equals(Object obj) {
      return obj instanceof RegexpStringLiteral && ((RegexpStringLiteral) obj).image == this.image;
  }
  
  public int hashCode() {
      return image.hashCode();
  }

  public boolean matchesEmptyString() {
      return getImage().length() == 0;
  }
}

#RegexpRef : 
{
   Token t;
}
    "<"
    t=<IDENTIFIER> =>||
    DEACTIVATE_TOKENS RSIGNEDSHIFT, RUNSIGNEDSHIFT (">") 
    {
       CURRENT_NODE.setLabel(t.getImage());
       return CURRENT_NODE;
    }
;

INJECT RegexpRef : 
    import org.congocc.core.*;
    extends RegularExpression;
{
    @Property RegularExpression regexp;

    public boolean isPrivate() {
        return regexp!= null && regexp.isPrivate(); 
    }

    public boolean matchesEmptyString() {
        return regexp != null && regexp.matchesEmptyString();
    }

    public int getOrdinal() {
        if (regexp == null) {
            // This is the case if this RegexpRef refers to a token type
            // specified in the EXTRA_TOKENS
            int extraTokensIndex = getGrammar().getExtraTokenNames().indexOf(getLabel());
            assert extraTokensIndex >=0;
            return extraTokensIndex + getGrammar().getLexerData().getRegularExpressions().size();
        }
        return regexp.getOrdinal();
    }
}

EndOfFile : "<" <_EOF> =>|| ">" ;

INJECT EndOfFile : extends org.congocc.core.RegularExpression
{
    public boolean matchesEmptyString() {return true;}
}

RegexpChoice :
    RegexpSequence 
    ("|" RegexpSequence)*
;

RegexpChoiceInParen #RegexpChoice : 
   "(" RegexpSequence ("|" RegexpSequence)* ")"
;

INJECT RegexpChoice : 
    import java.util.List;
    import org.congocc.core.RegularExpression;
    extends RegularExpression;
{
    public List<RegularExpression> getChoices() {
        return childrenOfType(RegularExpression.class);
    }

    public boolean matchesEmptyString() {
        for (RegularExpression choice: getChoices()) {
            if (choice.matchesEmptyString()) {
                return true;
            }
        }
        return false;
    }
}

RegexpSequence :
   (
      RegexpStringLiteral
      |
      RegexpRef
      |
      CharacterList
      |
      RepeatedRegexp
   )+
;

INJECT RegexpSequence : 
   import java.util.*;
   import org.congocc.Grammar;
   import org.congocc.core.RegularExpression;
   extends RegularExpression;
{

   public RegexpSequence(Grammar grammar, List<RegularExpression> units) {
       super(grammar);
       for (RegularExpression re : units) addChild(re);
   }

   public RegexpSequence() {}

   public List<RegularExpression> getUnits() {
       return childrenOfType(RegularExpression.class);
   }

   public boolean matchesEmptyString() {
       for (RegularExpression child : getUnits()) {
           if (!child.matchesEmptyString()) return false;
       }
       return true;
   }
}

RepeatedRegexp #void : 
{
     int r1 = 0, r2 = -1;
}
  RegexpChoiceInParen
  (  "+" #OneOrMoreRegexp(2) 
   | "*" #ZeroOrMoreRegexp(2)
   | "?" #ZeroOrOneRegexp(2) 
   | (
      "{" <INTEGER_LITERAL> {r1 = ((IntegerLiteral)lastConsumedToken).getValue();}
           [ "," [ <INTEGER_LITERAL> {r2=((IntegerLiteral)lastConsumedToken).getValue();} ] ]
       "}"
     ) #RepetitionRange(+1) 
     {
         RepetitionRange range = (RepetitionRange) peekNode();
         range.setMin(r1);
         range.setMax(r2);
     }
  )?
;

INJECT RepetitionRange : 
   import org.congocc.core.RegularExpression;
   extends RegularExpression;
{
    @Property int min = 0, max = -1;

    public boolean hasMax() {
        return firstChildOfType(COMMA) != null;
    }
    
    public RegularExpression getRegexp() { 
        return firstChildOfType(RegularExpression.class);
    }

    public boolean matchesEmptyString() {
        return min==0 || getRegexp().matchesEmptyString();
    }
}

INJECT OneOrMoreRegexp : 
   import org.congocc.core.RegularExpression;
   extends RegularExpression;
{
   public RegularExpression getRegexp() 
   {
      return firstChildOfType(RegularExpression.class);
   }

   public boolean matchesEmptyString() {
       return getRegexp().matchesEmptyString(); 
   }
}

INJECT ZeroOrMoreRegexp : 
   import org.congocc.core.RegularExpression;
   extends RegularExpression;
{
   public RegularExpression getRegexp() 
   {
      return firstChildOfType(RegularExpression.class);
   }
   
   public void setRegexp(RegularExpression regexp) {
      RegularExpression current = getRegexp();
      if (current != null) {
          replaceChild(current, regexp);
      } else {
          addChild(0, regexp);
      }
   }

   public boolean matchesEmptyString() {
       return true;
   }
}

INJECT ZeroOrOneRegexp : 
   import org.congocc.core.RegularExpression;
   extends RegularExpression;
{
   public RegularExpression getRegexp() 
   {
      return firstChildOfType(RegularExpression.class);
   }
   
   public void setRegexp(RegularExpression regexp) {
      RegularExpression current = getRegexp();
      if (current != null) {
          addChild(indexOf(current), regexp);
          removeChild(current);
      } else {
          addChild(0, regexp);
      }
   }

   public boolean matchesEmptyString() {
       return true;
   }
}

CharacterList :
  ["~"]
  "[" [CharacterRange
        ( "," CharacterRange)*
      ]
  "]"
;

INJECT CharacterList : 
   import java.util.*;
   import org.congocc.core.*;
   extends RegularExpression;
{
    public List<CharacterRange> getDescriptors() {
        return childrenOfType(CharacterRange.class);
    }

    public boolean isNegated() {
        return firstChildOfType(TILDE) != null;
    }

    public boolean matchesEmptyString() {
            return false;
        }
    }

CharacterRange# :
    (<STRING_LITERAL>|<CHARACTER_LITERAL>)
    [ 
    "-"
    (<STRING_LITERAL>|<CHARACTER_LITERAL>)
   ]
;

INJECT CharacterRange :
  import java.util.ArrayList;
{
    @Property int left, right;
    
    public CharacterRange() {} 
    
    public CharacterRange(int left, int right) {
        setRange(left, right);
    }
    
    public void setRange(int left, int right) {
        if (left > right) {
            throw new ArrayIndexOutOfBoundsException();
        }
        this.left = left;
        this.right = right;
    }

    public boolean isSingleChar() {
       return left == right;
    }

    static private boolean isSingleChar(String s) {
       if (s.length() == 1) return true;
       if (s.length() == 2) {
           return Character.isSurrogatePair(s.charAt(0), s.charAt(1));
       }
       return false;
    }

    public void close() {
        java.util.List<Token> bounds = new ArrayList<>();
        for (Node n : children()) {
            if (n instanceof StringLiteral) bounds.add((Token) n);
            if (n instanceof CharacterLiteral) bounds.add((Token) n);
            if (bounds.size() >1) break;
        }
        String leftBound = StringLiteral.removeEscapesAndQuotes(bounds.get(0).getImage());
        String rightBound = leftBound;
        if (bounds.size() >1) {
            rightBound = StringLiteral.removeEscapesAndQuotes(bounds.get(1).getImage());
        }
        if (!isSingleChar(leftBound)) {
            getGrammar().addError(bounds.get(0),
                    "String in character list may contain only one character.");
        }
        this.left = this.right = leftBound.codePointAt(0);
        if (!leftBound.equals(rightBound)) {
            if (!isSingleChar(rightBound)) {
                getGrammar().addError(bounds.get(1),
                        "String in character list may contain only one character.");
            }
        }
        if (bounds.size()>1) {
            String right = StringLiteral.removeEscapesAndQuotes(bounds.get(1).getImage());
            if (!isSingleChar(right)) {
                getGrammar().addError(bounds.get(1),
                        "String in character list may contain only one character.");
            }
            this.right = right.codePointAt(0);
        }
        if (this.left>this.right) {
            getGrammar().addError(this, "The left side of the character range must be a lower ordinal (in Unicode) value than the right side.");
        }
    }
}
