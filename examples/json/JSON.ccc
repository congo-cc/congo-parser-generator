/*
 * Author: Jonathan Revusky revusky@congocc.org
 * This JSON Grammar is free to use or adapt.
 * It is (as far as I can tell) an EXACT implementation
 * of the spec found here: https://www.json.org/json-en.html
 * That means that you cannot put comments in there.
 * Also, you cannot put trailing commas inside hashes and lists.
 * There is an accompanying JSONC (JSON with comments) grammar
 * in JSONC.ccc. That allows Java-style comments but
 * still does not allow the trailing commas!
 */

 //N.B. The various exclam (!) markers inserted have to do with 
 // experimental fault-tolerant parsing. Unless you set FAULT_TOLERANT=true
 // these are ignored.

PARSER_PACKAGE="org.parsers.json";
NODE_PACKAGE="org.parsers.json.ast";
DEFAULT_LEXICAL_STATE=JSON;
USES_PREPROCESSOR;

#if localtest
X_SYNTHETIC_NODES_ENABLED;
#endif

SKIP : <WHITESPACE : (" "| "\t"| "\n"| "\r")+>; 

// Delimiters
TOKEN #Delimiter :
    <COLON : ':'>
    |
    <COMMA : ','>
    |
    <OPEN_BRACKET : '['>
    |
    <CLOSE_BRACKET : ']'>
    |
    <OPEN_BRACE : "{" >
    |
    <CLOSE_BRACE : "}">
;

// Literals
TOKEN #Literal :
    <TRUE: 'true'> #BooleanLiteral
    |
    <FALSE: "false"> #BooleanLiteral
    |
    <NULL: "null"> #NullLiteral
    |
    <#ESCAPE1 : '\\' (['\\', '"', '/',"b","f","n","r","t"])>
    |
    <#ESCAPE2 : "\\u" (["0"-"9", "a"-"f", "A"-"F"]) {4}>
    |
    <#REGULAR_CHAR : ~["\u0000"-"\u001F",'"',"\\"]>
    |
    <STRING_LITERAL : "\"" (<REGULAR_CHAR>|<ESCAPE2>|<ESCAPE1>)* "\""> #StringLiteral
    |
    <#ZERO : "0">
    |
    <#NON_ZERO : (['1'-'9'])(["0"-"9"])*>
    |
    <#FRACTION : "." (["0"-"9"])+>
    |
    <#EXPONENT : ["E","e"]["+","-"](["1"-"9"])+>
    |
    <NUMBER : ("-")?(<ZERO>|<NON_ZERO>)(<FRACTION>)?(<EXPONENT>)?> #NumberLiteral
;

Root : Value! <EOF>! ;

#if localtest

/***
 *  The following parses the same input as the previous productions, but uses extended Congo tree-node-building features and
 *  Java actions to assert the expected behavior.  The may also be used as examples of the use of these features.
 */

INJECT PARSER_CLASS :
{
    import NODE_PACKAGE.Delimiter;
    import java.util.List;
}
{}

INJECT Array :
{
    @Property Token aCommaToken = null;
}

Array :
{   
    Token openBracket = null;
    ACommaNode aCommaNode = null;
}
    /**
     * The "[" token is assigned to local variable "openBracket" and the token is wrapped in the tree node "AnOpenBracket".
     */
    openBracket = <OPEN_BRACKET> #AnOpenBracket 
        {
#if __java__ 
            assert((openBracket instanceof Delimiter) && openBracket.toString().equals("[")) : "openBracket local variable not assigned to '['";           
            assert(peekNode().get(0).equals(openBracket)) : "unconditional tree node AnOpenBracket does not have a child = to '['";
#endif
#if __python__
            assert(/*DOESN'T WORK FOR PYTHON:(openBracket instanceof Delimiter) && */openBracket.toString().equals("[")) : "openBracket local variable not assigned to \"[\"";
            assert(peekNode().getChild(0).equals(openBracket)) : "unconditional tree node AnOpenBracket does not have a child = to '['";
#endif
#if __csharp__
            assert((openBracket instanceof Delimiter) && openBracket.toString().equals("[")) : "openBracket local variable not assigned to '['";
            assert(peekNode().getChild(0).equals(openBracket)) : "unconditional tree node AnOpenBracket does not have a child = to '['";
#endif
        }
    @optionalArrayElements :=$ [
        /**
         * The "Value" node is added (as the first element) to a child list named "values" in the "Array" node
         * and the "Value" node is then wrapped in a "BaseNode" which is assigned to a list property named "values" 
         * automatically defined in the "Array" node.
         *
         * Illustrative alternatives using other features and achieving approximately the same result are:
         *  Value (<COMMA> Value)*!
         *  Value /[values]/ (<COMMA> Value /[values]/)*!
         *  /values/ += Value (<COMMA> (/values/ += Value))*!  // note the disambiguation required after <COMMA>
         */
        @values :+= ( /values/ += Value )
        {
#if __java__
            assert(thisProduction.getValues() instanceof List) : "values property not type List";
            // Can't access a property in a manner compatible with both Java and CSharp? 
            // But can with Python, however, the instanceof does not recognize "List".
#endif
            assert(thisProduction.getNamedChildList("values").size() == 1) : "named child list 'values' should have 1 node at this point";            
        } 
        /**
         * A boolean property named "moreThanOne" is automatically injected into the "Array" node and a ZeroOrMore expansion is parsed and, 
         * iff it exists (has one or more elements), the "moreThanOne" property is set to true.
         */
        @moreThanOne :=? (
            /**
             * The token "," is added to an explicitly injected @Property named "commaTokens" in the "Array" node, and
             * an unconditional tree node called "ACommaNode" is built and wraps the "," token.
             */
            @commaTokens :+= <COMMA> aCommaNode = #ACommaNode 
                {
#if __java__
                    assert(aCommaNode.get(0).toString().equals(thisProduction.getCommaTokens().get(0).toString())) : "the ACommaNode does not have a child token that is = the property commaTokens[0] in the Array node";
                    // can't access a property in a manner compatible with CSharp and Python?
#endif
                }
            /**
             * A "Value" node is built and a reference to it is added as a child of the "Array" property named "values", and
             * a reference to the same "Value" node is added to the named child list "values" of the anonymous BaseNode added by the 'moreThanOne' property assignment.
             * N.B., This illustrates a significant semantic difference between the behavior of the "/name/ += ..." construct and the "... /name/" construct.  The former
             * ALWAYS references the properties of the production node instance (i.e. the node that is open before parsing the first expansion), whereas the latter references the named child or list
             * of the node last closed. 
             */
            @values += Value /[values]/ 
                {
#if __java__
                    assert(thisProduction.getValues().size() == CURRENT_NODE.getNamedChildList("values").size() + 1) : "the List<Node> property 'values' size is not one more than the child list named 'values' in the 'moreThanOne' node added previously";
                    // can't access a property in a manner compatible with both Java and CSharp?
#endif
#if __python__
                    assert(thisProduction.getValues().size() == CURRENT_NODE.getNamedChildList("values").size() + 1) : "the BaseNode property 'values' size is not one more than the child list named 'values' in the 'moreThanOne' node added previously";
#endif

                }
        )*! 
    ]
    <CLOSE_BRACKET>
;

Value :
    ( <TRUE>
    |
    <FALSE>
    |
    <NULL>
    |
    <STRING_LITERAL>
    |
    <NUMBER>
    |
    Array
    |
    JSONObject )
    
;

KeyValuePair : 
    @key :=$ <STRING_LITERAL> 
    <COLON> 
    @value := Value
;

JSONObject : 
    <OPEN_BRACE>!
    [
        KeyValuePair ("," KeyValuePair)*!
    ]
    <CLOSE_BRACE>!
;

#else

Array :
    <OPEN_BRACKET>
    [
      Value (<COMMA> Value)*!
    ]
    <CLOSE_BRACKET>
;

Value :
    ( <TRUE>
    |
    <FALSE>
    |
    <NULL>
    |
    <STRING_LITERAL>
    |
    <NUMBER>
    |
    Array
    |
    JSONObject )
    
;

KeyValuePair : <STRING_LITERAL> <COLON> Value;

JSONObject : 
    <OPEN_BRACE>!
    [
        KeyValuePair ("," KeyValuePair)*!
    ]
    <CLOSE_BRACE>!
;

#endif
